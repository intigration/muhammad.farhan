import{provide as k,mergeProps as x,withCtx as a,createTextVNode as o,createVNode as t,unref as m,useSSRContext as A}from"vue";import{ssrRenderComponent as s}from"vue/server-renderer";import{c as f}from"./page-utils-C-QWsEHe.js";import{D as O,a as l}from"./DocPage-DKr-0pQn.js";import{D as c}from"./DocExample-BcaABDtE.js";import{D as g}from"./DocApi-Df9ryd6x.js";import{_ as C}from"../server-entry.js";import"quasar";import"@quasar/extras/mdi-v6";import"@quasar/extras/fontawesome-v6";import"@quasar/extras/mdi-v7";import"./DocCode-BVg0tuSc.js";import"prismjs";import"./CopyButton-l3ndfN49.js";import"./DocCodepen-BPVszLIH.js";import"./utils-DKnLoYai.js";import"./DocCardTitle-BSnqQsiz.js";import"vue-router";import"@quasar/extras/fontawesome-v5";import"quasar/icon-set/svg-mdi-v6.mjs";const y={__name:"intersection",__ssrInlineRender:!0,setup(b){k("_q_ex",{name:"QIntersection"});const w=[{name:"Intersection",category:"Vue Directives",path:"/vue-directives/intersection"},{name:"Transitions",category:"Options & Helpers",path:"/options/transitions"}],h=[{id:"qintersection-api",title:"2. QIntersection API",deep:!0},{id:"usage",title:"3. Usage"},{id:"basic",title:"3.1. Basic",sub:!0},{id:"with-transition",title:"3.2. With transition",sub:!0},{id:"only-once",title:"3.3. Only once",sub:!0}];return(D,$,T,I)=>{$(s(O,x({title:"Intersection",desc:"The QIntersection vue component, a wrapper over Quasar's Intersection directive.",heading:"","edit-link":"vue-components/intersection",toc:h,related:w},I),{default:a((N,n,r,e)=>{if(n)n(`<p${e}>The QIntersection component is essentially a wrapper over the `),n(s(l,{to:"/vue-directives/intersection"},{default:a((d,i,p,u)=>{if(i)i("Intersection directive");else return[o("Intersection directive")]}),_:1},r,e)),n(` with the added benefit that it handles the state by itself (does not require you to add it and handle it manually) and can optionally have a show/hide transition as well.</p><p${e}>The main benefit of using QIntersection is, however, that the DOM tree is freed up of hidden nodes thus using the minimum possible RAM memory and making the page feel very snappy. As well, you can specify the <code class="doc-token"${e}>tag</code> property for the wrapper element to match your own needs, thus eliminating yet another DOM node.</p><p${e}>Under the hood, it uses the `),n(s(l,{to:"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"},{default:a((d,i,p,u)=>{if(i)i("Intersection Observer API");else return[o("Intersection Observer API")]}),_:1},r,e)),n(`.</p><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>Not all browsers support the Intersection Observer API. Most `),n(s(l,{to:"https://caniuse.com/#search=intersection"},{default:a((d,i,p,u)=>{if(i)i("modern browsers");else return[o("modern browsers")]}),_:1},r,e)),n(" do, but other browsers do not. If you need to support older browsers, you can install and import (into a boot file) the official W3C "),n(s(l,{to:"https://github.com/w3c/IntersectionObserver"},{default:a((d,i,p,u)=>{if(i)i("polyfill");else return[o("polyfill")]}),_:1},r,e)),n(".</p></div>"),n(s(g,{file:"QIntersection"},null,r,e)),n(`<h2 id="usage" class="doc-heading doc-h2"${e}>Usage</h2><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>In most cases, it is required that you apply CSS to the QIntersection element so that it acts as a necessary filler when the inner content is not rendered. This will allow for a smooth scrolling experience, because otherwise the scroll will jump erratically.</p><p${e}>An example of such needed CSS would be, for example, a fixed height or at least a min-height (and possibly even a fixed width, as in the examples below, where multiple QIntersections can be displayed on same row).</p></div><div class="doc-note doc-note--danger"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>If using the <code class="doc-token"${e}>transition</code> prop, it is required that the content be wrapped in one and only one element.</p></div><div class="doc-note doc-note--tip"${e}><p class="doc-note__title"${e}>TIP</p><p${e}>There are edge cases where the default viewport won’t work. For instance, when your code is hosted in an iframe (like Codepen). This is where you need to use the <code class="doc-token"${e}>root</code> property. It allows you to define an alternative to the viewport as your root (through its DOM element). It is important to keep in mind that root needs to be an ancestor of the observed element.</p></div><h3 id="basic" class="doc-heading doc-h3"${e}>Basic</h3>`),n(s(c,{title:"Basic",file:"Basic",scrollable:"","no-edit":""},null,r,e)),n(`<h3 id="with-transition" class="doc-heading doc-h3"${e}>With transition</h3><p${e}>In the example below we used a Quasar transition. For a full list, please head to `),n(s(l,{to:"/options/transitions"},{default:a((d,i,p,u)=>{if(i)i("Transitions");else return[o("Transitions")]}),_:1},r,e)),n(" page.</p>"),n(s(c,{title:"With transition",file:"Transition",scrollable:"","no-edit":""},null,r,e)),n(s(c,{title:"A list with transition",file:"List",scrollable:"","no-edit":""},null,r,e)),n(`<h3 id="only-once" class="doc-heading doc-h3"${e}>Only once</h3><p${e}>Triggering only once means, however, that you lose the benefit of freeing up the DOM tree. The content will remain in DOM regardless of visibility.</p>`),n(s(c,{title:"Triggering only once",file:"Once",scrollable:"","no-edit":""},null,r,e)),n(`<p${e}>The example below uses the <code class="doc-token"${e}>root</code> property and therefore can be seen in a Codepen (which hosts in an iframe).</p>`),n(s(c,{title:"Root viewport",file:"Root"},null,r,e));else return[t("p",null,[o("The QIntersection component is essentially a wrapper over the "),t(l,{to:"/vue-directives/intersection"},{default:a(()=>[o("Intersection directive")]),_:1}),o(" with the added benefit that it handles the state by itself (does not require you to add it and handle it manually) and can optionally have a show/hide transition as well.")]),t("p",null,[o("The main benefit of using QIntersection is, however, that the DOM tree is freed up of hidden nodes thus using the minimum possible RAM memory and making the page feel very snappy. As well, you can specify the "),t("code",{class:"doc-token"},"tag"),o(" property for the wrapper element to match your own needs, thus eliminating yet another DOM node.")]),t("p",null,[o("Under the hood, it uses the "),t(l,{to:"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"},{default:a(()=>[o("Intersection Observer API")]),_:1}),o(".")]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("Not all browsers support the Intersection Observer API. Most "),t(l,{to:"https://caniuse.com/#search=intersection"},{default:a(()=>[o("modern browsers")]),_:1}),o(" do, but other browsers do not. If you need to support older browsers, you can install and import (into a boot file) the official W3C "),t(l,{to:"https://github.com/w3c/IntersectionObserver"},{default:a(()=>[o("polyfill")]),_:1}),o(".")])]),t(g,{file:"QIntersection"}),t("h2",{id:"usage",class:"doc-heading doc-h2",onClick:d=>m(f)("usage")},"Usage",8,["onClick"]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,"In most cases, it is required that you apply CSS to the QIntersection element so that it acts as a necessary filler when the inner content is not rendered. This will allow for a smooth scrolling experience, because otherwise the scroll will jump erratically."),t("p",null,"An example of such needed CSS would be, for example, a fixed height or at least a min-height (and possibly even a fixed width, as in the examples below, where multiple QIntersections can be displayed on same row).")]),t("div",{class:"doc-note doc-note--danger"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("If using the "),t("code",{class:"doc-token"},"transition"),o(" prop, it is required that the content be wrapped in one and only one element.")])]),t("div",{class:"doc-note doc-note--tip"},[t("p",{class:"doc-note__title"},"TIP"),t("p",null,[o("There are edge cases where the default viewport won’t work. For instance, when your code is hosted in an iframe (like Codepen). This is where you need to use the "),t("code",{class:"doc-token"},"root"),o(" property. It allows you to define an alternative to the viewport as your root (through its DOM element). It is important to keep in mind that root needs to be an ancestor of the observed element.")])]),t("h3",{id:"basic",class:"doc-heading doc-h3",onClick:d=>m(f)("basic")},"Basic",8,["onClick"]),t(c,{title:"Basic",file:"Basic",scrollable:"","no-edit":""}),t("h3",{id:"with-transition",class:"doc-heading doc-h3",onClick:d=>m(f)("with-transition")},"With transition",8,["onClick"]),t("p",null,[o("In the example below we used a Quasar transition. For a full list, please head to "),t(l,{to:"/options/transitions"},{default:a(()=>[o("Transitions")]),_:1}),o(" page.")]),t(c,{title:"With transition",file:"Transition",scrollable:"","no-edit":""}),t(c,{title:"A list with transition",file:"List",scrollable:"","no-edit":""}),t("h3",{id:"only-once",class:"doc-heading doc-h3",onClick:d=>m(f)("only-once")},"Only once",8,["onClick"]),t("p",null,"Triggering only once means, however, that you lose the benefit of freeing up the DOM tree. The content will remain in DOM regardless of visibility."),t(c,{title:"Triggering only once",file:"Once",scrollable:"","no-edit":""}),t("p",null,[o("The example below uses the "),t("code",{class:"doc-token"},"root"),o(" property and therefore can be seen in a Codepen (which hosts in an iframe).")]),t(c,{title:"Root viewport",file:"Root"})]}),_:1},T))}}},v=y.setup;y.setup=(b,w)=>{const h=A();return(h.modules||(h.modules=new Set)).add("src/pages/vue-components/intersection.md"),v?v(b,w):void 0};const Y=C(y,[["__file","intersection.md"]]);export{Y as default};
