import{resolveComponent as w,mergeProps as b,withCtx as a,createTextVNode as r,createVNode as t,unref as S,useSSRContext as k}from"vue";import{ssrRenderComponent as s}from"vue/server-renderer";import{c as R}from"./page-utils-C-QWsEHe.js";import{D as x,a as h}from"./DocPage-DKr-0pQn.js";import{_ as $}from"../server-entry.js";import"quasar";import"@quasar/extras/mdi-v6";import"vue-router";import"@quasar/extras/fontawesome-v5";import"@quasar/extras/fontawesome-v6";import"@quasar/extras/mdi-v7";import"quasar/icon-set/svg-mdi-v6.mjs";const l={__name:"introduction",__ssrInlineRender:!0,setup(d){const n=[{id:"why-ssr",title:"2. Why SSR?"}];return(i,f,g,y)=>{const c=w("q-separator");f(s(x,b({title:"What is SSR",desc:"(@quasar/app-vite) Introduction on server-side rendered apps with Quasar CLI.",overline:"Quasar CLI with Vite - @quasar/app-vite",heading:"","edit-link":"quasar-cli-vite/developing-ssr/introduction",toc:n},y),{default:a((j,o,u,e)=>{if(o)o(`<p${e}>Quasar and Vue.js are frameworks for building client-side applications. By default, Quasar Vue components produce and manipulate DOM in the browser as output. However, it is also possible to render the same components into HTML strings on the server, send them directly to the browser, and finally “hydrate” the static markup into a fully interactive app on the client.</p><p${e}>A server-rendered Quasar app can also be considered <code class="doc-token"${e}>isomorphic</code> or <code class="doc-token"${e}>universal</code>, in the sense that the majority of your app’s code runs on both the server and the client.</p><h2 id="why-ssr" class="doc-heading doc-h2"${e}>Why SSR?</h2><p${e}>Compared to a traditional SPA (Single-Page Application), the advantage of SSR primarily lies in:</p><ul${e}><li${e}><strong${e}>Better SEO</strong>, as the search engine crawlers will directly see the fully rendered page.</li><li${e}><strong${e}>Faster time-to-content</strong>, especially on slow internet or slow devices. Server-rendered markup doesn’t need to wait until all JavaScript has been downloaded and executed to be displayed, so your user will see a fully-rendered page sooner. This generally results in better user experience, and can be critical for applications where time-to-content is directly associated with conversion rate.</li></ul><p${e}>There are also some trade-offs to consider when using SSR:</p><ul${e}><li${e}><strong${e}>Development constraints</strong>. Browser-specific code can only be used inside certain lifecycle hooks; some external libraries may need special treatment to be able to run in a server-rendered app.</li><li${e}><strong${e}>More server-side load</strong>. Rendering a full app in Node.js is obviously going to be more CPU-intensive than just serving static files, so if you expect high traffic, be prepared for corresponding server load and wisely employ caching strategies.</li></ul><p${e}>Before using SSR for your app, the first question you should ask is whether you actually need it. It mostly depends on how important time-to-content is for your app. For example, if you are building an internal dashboard where an extra few hundred milliseconds on initial load doesn’t matter that much, SSR would be an overkill. However, in cases where time-to-content is absolutely critical, SSR can help you achieve the best possible initial load performance.</p>`),o(s(c,{class:"q-mt-xl"},null,u,e)),o(`<blockquote class="doc-note"${e}><p${e}>Parts of this page are taken from the official `),o(s(h,{to:"https://vuejs.org/guide/scaling-up/ssr.html"},{default:a((v,p,q,C)=>{if(p)p("Vue.js SSR guide");else return[r("Vue.js SSR guide")]}),_:1},u,e)),o(".</p></blockquote>");else return[t("p",null,"Quasar and Vue.js are frameworks for building client-side applications. By default, Quasar Vue components produce and manipulate DOM in the browser as output. However, it is also possible to render the same components into HTML strings on the server, send them directly to the browser, and finally “hydrate” the static markup into a fully interactive app on the client."),t("p",null,[r("A server-rendered Quasar app can also be considered "),t("code",{class:"doc-token"},"isomorphic"),r(" or "),t("code",{class:"doc-token"},"universal"),r(", in the sense that the majority of your app’s code runs on both the server and the client.")]),t("h2",{id:"why-ssr",class:"doc-heading doc-h2",onClick:v=>S(R)("why-ssr")},"Why SSR?",8,["onClick"]),t("p",null,"Compared to a traditional SPA (Single-Page Application), the advantage of SSR primarily lies in:"),t("ul",null,[t("li",null,[t("strong",null,"Better SEO"),r(", as the search engine crawlers will directly see the fully rendered page.")]),t("li",null,[t("strong",null,"Faster time-to-content"),r(", especially on slow internet or slow devices. Server-rendered markup doesn’t need to wait until all JavaScript has been downloaded and executed to be displayed, so your user will see a fully-rendered page sooner. This generally results in better user experience, and can be critical for applications where time-to-content is directly associated with conversion rate.")])]),t("p",null,"There are also some trade-offs to consider when using SSR:"),t("ul",null,[t("li",null,[t("strong",null,"Development constraints"),r(". Browser-specific code can only be used inside certain lifecycle hooks; some external libraries may need special treatment to be able to run in a server-rendered app.")]),t("li",null,[t("strong",null,"More server-side load"),r(". Rendering a full app in Node.js is obviously going to be more CPU-intensive than just serving static files, so if you expect high traffic, be prepared for corresponding server load and wisely employ caching strategies.")])]),t("p",null,"Before using SSR for your app, the first question you should ask is whether you actually need it. It mostly depends on how important time-to-content is for your app. For example, if you are building an internal dashboard where an extra few hundred milliseconds on initial load doesn’t matter that much, SSR would be an overkill. However, in cases where time-to-content is absolutely critical, SSR can help you achieve the best possible initial load performance."),t(c,{class:"q-mt-xl"}),t("blockquote",{class:"doc-note"},[t("p",null,[r("Parts of this page are taken from the official "),t(h,{to:"https://vuejs.org/guide/scaling-up/ssr.html"},{default:a(()=>[r("Vue.js SSR guide")]),_:1}),r(".")])])]}),_:1},g))}}},m=l.setup;l.setup=(d,n)=>{const i=k();return(i.modules||(i.modules=new Set)).add("src/pages/quasar-cli-vite/developing-ssr/introduction.md"),m?m(d,n):void 0};const O=$(l,[["__file","introduction.md"]]);export{O as default};
