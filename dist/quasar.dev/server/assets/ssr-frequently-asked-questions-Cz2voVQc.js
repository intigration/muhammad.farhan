import{mergeProps as q,withCtx as r,createTextVNode as n,unref as u,createVNode as e,useSSRContext as C}from"vue";import{ssrRenderComponent as c}from"vue/server-renderer";import{c as h}from"./page-utils-C-QWsEHe.js";import{D as P,a as i}from"./DocPage-DKr-0pQn.js";import{D as y}from"./DocPrerender-DPOnWPFO.js";import{C as f}from"./CopyButton-l3ndfN49.js";import{_ as x}from"../server-entry.js";import"quasar";import"@quasar/extras/mdi-v6";import"vue-router";import"@quasar/extras/fontawesome-v5";import"@quasar/extras/fontawesome-v6";import"@quasar/extras/mdi-v7";import"quasar/icon-set/svg-mdi-v6.mjs";const g={__name:"ssr-frequently-asked-questions",__ssrInlineRender:!0,setup(w){const k=[{id:"why-am-i-getting-hydration-errors",title:"2. Why am I getting hydration errors?"},{id:"why-doesnt-importing-platform-and-cookies-work",title:"3. Why doesn’t importing Platform and Cookies work?"},{id:"why-isnt-localstorage-and-sessionstorage-working",title:"4. Why isn’t LocalStorage and SessionStorage working?"}];return(m,v,b,S)=>{v(c(P,q({title:"SSR FAQ",desc:"(@quasar/app-webpack) Tips and tricks for a Quasar server-side rendered app.",overline:"Quasar CLI with Webpack - @quasar/app-webpack",heading:"","edit-link":"quasar-cli-webpack/developing-ssr/ssr-frequently-asked-questions",toc:k},S),{default:r((W,a,p,s)=>{if(a)a(`<h2 id="why-am-i-getting-hydration-errors" class="doc-heading doc-h2"${s}>Why am I getting hydration errors?</h2><p${s}>Take a look at our `),a(c(i,{to:"/quasar-cli-webpack/developing-ssr/client-side-hydration"},{default:r((l,o,d,t)=>{if(o)o("Client Side Hydration");else return[n("Client Side Hydration")]}),_:1},p,s)),a(" page. When you get hydration errors, it means the HTML rendered on the server does not match the equivalent HTML rendered on client-side. This error will appear only when developing (and NOT on production) and it definitely needs to be addressed, before you release your website. Is there some content that you can only generate on client-side? Then use "),a(c(i,{to:"/vue-components/no-ssr"},{default:r((l,o,d,t)=>{if(o)o("QNoSsr");else return[n("QNoSsr")]}),_:1},p,s)),a(`.</p><h2 id="why-doesnt-importing-platform-and-cookies-work" class="doc-heading doc-h2"${s}>Why doesn’t importing Platform and Cookies work?</h2><p${s}>When building for SSR, use only the <code class="doc-token"${s}>$q.platform</code> / <code class="doc-token"${s}>$q.cookies</code> form. Alternatively, when on server-side, this is one more example of how you can use it:</p>`),a(c(u(y),null,{default:r((l,o,d,t)=>{if(o)o(`<pre class="doc-code"${t}><code${t}><span class="token comment"${t}>// example with Platform; same thing for Cookies</span>
<span class="token keyword"${t}>import</span> <span class="token punctuation"${t}>{</span> Platform <span class="token punctuation"${t}>}</span> <span class="token keyword"${t}>from</span> <span class="token string"${t}>&#39;quasar&#39;</span>

<span class="token comment"${t}>// you need access to \`ssrContext\`</span>
<span class="token keyword"${t}>function</span> <span class="token punctuation"${t}>(</span><span class="token parameter"${t}>ssrContext</span><span class="token punctuation"${t}>)</span> <span class="token punctuation"${t}>{</span>
  <span class="token keyword"${t}>const</span> platform <span class="token operator"${t}>=</span> process<span class="token punctuation"${t}>.</span>env<span class="token punctuation"${t}>.</span><span class="token constant"${t}>SERVER</span>
    <span class="token operator"${t}>?</span> Platform<span class="token punctuation"${t}>.</span><span class="token function"${t}>parseSSR</span><span class="token punctuation"${t}>(</span>ssrContext<span class="token punctuation"${t}>)</span>
    <span class="token operator"${t}>:</span> Platform <span class="token comment"${t}>// otherwise we&#39;re on client</span>

  <span class="token comment"${t}>// platform is equivalent to the global import as in non-SSR builds</span>
<span class="token punctuation"${t}>}</span></code></pre>`),o(c(f,null,null,d,t));else return[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token comment"},"// example with Platform; same thing for Cookies"),n(`
`),e("span",{class:"token keyword"},"import"),n(),e("span",{class:"token punctuation"},"{"),n(" Platform "),e("span",{class:"token punctuation"},"}"),n(),e("span",{class:"token keyword"},"from"),n(),e("span",{class:"token string"},"'quasar'"),n(`

`),e("span",{class:"token comment"},"// you need access to `ssrContext`"),n(`
`),e("span",{class:"token keyword"},"function"),n(),e("span",{class:"token punctuation"},"("),e("span",{class:"token parameter"},"ssrContext"),e("span",{class:"token punctuation"},")"),n(),e("span",{class:"token punctuation"},"{"),n(`
  `),e("span",{class:"token keyword"},"const"),n(" platform "),e("span",{class:"token operator"},"="),n(" process"),e("span",{class:"token punctuation"},"."),n("env"),e("span",{class:"token punctuation"},"."),e("span",{class:"token constant"},"SERVER"),n(`
    `),e("span",{class:"token operator"},"?"),n(" Platform"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"parseSSR"),e("span",{class:"token punctuation"},"("),n("ssrContext"),e("span",{class:"token punctuation"},")"),n(`
    `),e("span",{class:"token operator"},":"),n(" Platform "),e("span",{class:"token comment"},"// otherwise we're on client"),n(`

  `),e("span",{class:"token comment"},"// platform is equivalent to the global import as in non-SSR builds"),n(`
`),e("span",{class:"token punctuation"},"}")])]),e(f)]}),_:1},p,s)),a(`<p${s}>The <code class="doc-token"${s}>ssrContext</code> is available in the `),a(c(i,{to:"/quasar-cli-webpack/boot-files"},{default:r((l,o,d,t)=>{if(o)o("Boot Files");else return[n("Boot Files")]}),_:1},p,s)),a(" or the "),a(c(i,{to:"/quasar-cli-webpack/prefetch-feature"},{default:r((l,o,d,t)=>{if(o)o("PreFetch Feature");else return[n("PreFetch Feature")]}),_:1},p,s)),a(`, where it is supplied as a parameter.</p><p${s}>There is a good reason for this. In a client-only app, every user will be using a fresh instance of the app in their browser. For server-side rendering we want the same thing. Each request should have a fresh, isolated app instance so that there is no cross-request state pollution. So `),a(c(i,{to:"/options/platform-detection"},{default:r((l,o,d,t)=>{if(o)o("Platform");else return[n("Platform")]}),_:1},p,s)),a(" and "),a(c(i,{to:"/quasar-plugins/cookies"},{default:r((l,o,d,t)=>{if(o)o("Cookies");else return[n("Cookies")]}),_:1},p,s)),a(` need to be bound to each request separately.</p><p${s}>Also a good idea is to read the `),a(c(i,{to:"/quasar-cli-webpack/developing-ssr/writing-universal-code"},{default:r((l,o,d,t)=>{if(o)o("Writing Universal Code");else return[n("Writing Universal Code")]}),_:1},p,s)),a(` documentation page.</p><h2 id="why-isnt-localstorage-and-sessionstorage-working" class="doc-heading doc-h2"${s}>Why isn’t LocalStorage and SessionStorage working?</h2><p${s}>When running the code on server-side, the storage facilities can’t work. Web Storage is a browser only API.</p>`);else return[e("h2",{id:"why-am-i-getting-hydration-errors",class:"doc-heading doc-h2",onClick:l=>u(h)("why-am-i-getting-hydration-errors")},"Why am I getting hydration errors?",8,["onClick"]),e("p",null,[n("Take a look at our "),e(i,{to:"/quasar-cli-webpack/developing-ssr/client-side-hydration"},{default:r(()=>[n("Client Side Hydration")]),_:1}),n(" page. When you get hydration errors, it means the HTML rendered on the server does not match the equivalent HTML rendered on client-side. This error will appear only when developing (and NOT on production) and it definitely needs to be addressed, before you release your website. Is there some content that you can only generate on client-side? Then use "),e(i,{to:"/vue-components/no-ssr"},{default:r(()=>[n("QNoSsr")]),_:1}),n(".")]),e("h2",{id:"why-doesnt-importing-platform-and-cookies-work",class:"doc-heading doc-h2",onClick:l=>u(h)("why-doesnt-importing-platform-and-cookies-work")},"Why doesn’t importing Platform and Cookies work?",8,["onClick"]),e("p",null,[n("When building for SSR, use only the "),e("code",{class:"doc-token"},"$q.platform"),n(" / "),e("code",{class:"doc-token"},"$q.cookies"),n(" form. Alternatively, when on server-side, this is one more example of how you can use it:")]),e(u(y),null,{default:r(()=>[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token comment"},"// example with Platform; same thing for Cookies"),n(`
`),e("span",{class:"token keyword"},"import"),n(),e("span",{class:"token punctuation"},"{"),n(" Platform "),e("span",{class:"token punctuation"},"}"),n(),e("span",{class:"token keyword"},"from"),n(),e("span",{class:"token string"},"'quasar'"),n(`

`),e("span",{class:"token comment"},"// you need access to `ssrContext`"),n(`
`),e("span",{class:"token keyword"},"function"),n(),e("span",{class:"token punctuation"},"("),e("span",{class:"token parameter"},"ssrContext"),e("span",{class:"token punctuation"},")"),n(),e("span",{class:"token punctuation"},"{"),n(`
  `),e("span",{class:"token keyword"},"const"),n(" platform "),e("span",{class:"token operator"},"="),n(" process"),e("span",{class:"token punctuation"},"."),n("env"),e("span",{class:"token punctuation"},"."),e("span",{class:"token constant"},"SERVER"),n(`
    `),e("span",{class:"token operator"},"?"),n(" Platform"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"parseSSR"),e("span",{class:"token punctuation"},"("),n("ssrContext"),e("span",{class:"token punctuation"},")"),n(`
    `),e("span",{class:"token operator"},":"),n(" Platform "),e("span",{class:"token comment"},"// otherwise we're on client"),n(`

  `),e("span",{class:"token comment"},"// platform is equivalent to the global import as in non-SSR builds"),n(`
`),e("span",{class:"token punctuation"},"}")])]),e(f)]),_:1}),e("p",null,[n("The "),e("code",{class:"doc-token"},"ssrContext"),n(" is available in the "),e(i,{to:"/quasar-cli-webpack/boot-files"},{default:r(()=>[n("Boot Files")]),_:1}),n(" or the "),e(i,{to:"/quasar-cli-webpack/prefetch-feature"},{default:r(()=>[n("PreFetch Feature")]),_:1}),n(", where it is supplied as a parameter.")]),e("p",null,[n("There is a good reason for this. In a client-only app, every user will be using a fresh instance of the app in their browser. For server-side rendering we want the same thing. Each request should have a fresh, isolated app instance so that there is no cross-request state pollution. So "),e(i,{to:"/options/platform-detection"},{default:r(()=>[n("Platform")]),_:1}),n(" and "),e(i,{to:"/quasar-plugins/cookies"},{default:r(()=>[n("Cookies")]),_:1}),n(" need to be bound to each request separately.")]),e("p",null,[n("Also a good idea is to read the "),e(i,{to:"/quasar-cli-webpack/developing-ssr/writing-universal-code"},{default:r(()=>[n("Writing Universal Code")]),_:1}),n(" documentation page.")]),e("h2",{id:"why-isnt-localstorage-and-sessionstorage-working",class:"doc-heading doc-h2",onClick:l=>u(h)("why-isnt-localstorage-and-sessionstorage-working")},"Why isn’t LocalStorage and SessionStorage working?",8,["onClick"]),e("p",null,"When running the code on server-side, the storage facilities can’t work. Web Storage is a browser only API.")]}),_:1},b))}}},$=g.setup;g.setup=(w,k)=>{const m=C();return(m.modules||(m.modules=new Set)).add("src/pages/quasar-cli-webpack/developing-ssr/ssr-frequently-asked-questions.md"),$?$(w,k):void 0};const O=x(g,[["__file","ssr-frequently-asked-questions.md"]]);export{O as default};
