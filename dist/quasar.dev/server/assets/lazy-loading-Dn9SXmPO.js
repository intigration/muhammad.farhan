import{mergeProps as S,withCtx as l,createTextVNode as a,unref as c,createVNode as n,useSSRContext as j}from"vue";import{ssrRenderComponent as r}from"vue/server-renderer";import{c as y}from"./page-utils-C-QWsEHe.js";import{D as z,a as d}from"./DocPage-DKr-0pQn.js";import{D as u}from"./DocPrerender-DPOnWPFO.js";import{C as o}from"./CopyButton-l3ndfN49.js";import{_ as x}from"../server-entry.js";import"quasar";import"@quasar/extras/mdi-v6";import"vue-router";import"@quasar/extras/fontawesome-v5";import"@quasar/extras/fontawesome-v6";import"@quasar/extras/mdi-v7";import"quasar/icon-set/svg-mdi-v6.mjs";const $={__name:"lazy-loading",__ssrInlineRender:!0,setup(f){const g=[{id:"lazy-load-router-pages",title:"2. Lazy-load router pages"},{id:"lazy-load-components",title:"3. Lazy-load components"},{id:"lazy-load-on-the-fly",title:"4. Lazy-load on the fly"},{id:"caveat-with-vendor-imports",title:"5. Caveat with vendor imports"},{id:"caveat-for-dynamic-imports",title:"6. Caveat for dynamic imports"}];return(h,v,b,C)=>{v(r(z,S({title:"Lazy Loading / Code Splitting",desc:"(@quasar/app-webpack) How to create Webpack chunks in a Quasar app.",overline:"Quasar CLI with Webpack - @quasar/app-webpack",heading:"","edit-link":"quasar-cli-webpack/lazy-loading",toc:g},C),{default:l((q,p,m,t)=>{if(p)p(`<p${t}>When your website/app is small, you can load all layouts/pages/components into the initial bundle and serve everything at startup. But when your code gets complex and has many layouts/pages/components, it won’t be optimal to do this as it will massively impact loading time. Fortunately, there is a way to solve this.</p><p${t}>We’ll cover how you can lazy load / code split parts of your app so that they are automatically requested only on demand. This is done through dynamic imports. Let’s start with an example and then convert it so that we use lazy loading – we’ll focus this example on loading a page, but the same principle can be applied to load anything (assets, JSONs, …).</p><h2 id="lazy-load-router-pages" class="doc-heading doc-h2"${t}>Lazy-load router pages</h2><p${t}>It’s normal to use the Vue Router calling static components as below.</p><div class="doc-note doc-note--warning"${t}><p class="doc-note__title"${t}>WARNING</p><p${t}>Quasar documentation assumes you are already familiar with `),p(r(d,{to:"https://github.com/vuejs/vue-router"},{default:l((k,e,i,s)=>{if(e)e("Vue Router");else return[a("Vue Router")]}),_:1},m,t)),p(". Below it’s described only the basics of how to make use of it in a Quasar CLI project. For the full list of its features please visit the "),p(r(d,{to:"https://router.vuejs.org/"},{default:l((k,e,i,s)=>{if(e)e("Vue Router documentation");else return[a("Vue Router documentation")]}),_:1},m,t)),p(".</p></div>"),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token keyword"${s}>import</span> SomePage <span class="token keyword"${s}>from</span> <span class="token string"${s}>&#39;pages/SomePage&#39;</span>

<span class="token keyword"${s}>const</span> routes <span class="token operator"${s}>=</span> <span class="token punctuation"${s}>[</span>
  <span class="token punctuation"${s}>{</span>
    <span class="token literal-property property"${s}>path</span><span class="token operator"${s}>:</span> <span class="token string"${s}>&#39;/some-page&#39;</span><span class="token punctuation"${s}>,</span>
    <span class="token literal-property property"${s}>component</span><span class="token operator"${s}>:</span> SomePage
  <span class="token punctuation"${s}>}</span>
<span class="token punctuation"${s}>]</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),a(" SomePage "),n("span",{class:"token keyword"},"from"),a(),n("span",{class:"token string"},"'pages/SomePage'"),a(`

`),n("span",{class:"token keyword"},"const"),a(" routes "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"["),a(`
  `),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"path"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},"'/some-page'"),n("span",{class:"token punctuation"},","),a(`
    `),n("span",{class:"token literal-property property"},"component"),n("span",{class:"token operator"},":"),a(` SomePage
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"]")])]),n(o)]}),_:1},m,t)),p(`<p${t}>Now let’s change this and make the page be loaded on demand only, using dynamic imports:</p>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token keyword"${s}>const</span> routes <span class="token operator"${s}>=</span> <span class="token punctuation"${s}>[</span>
  <span class="token punctuation"${s}>{</span>
    <span class="token literal-property property"${s}>path</span><span class="token operator"${s}>:</span> <span class="token string"${s}>&#39;/some-page&#39;</span><span class="token punctuation"${s}>,</span>
    <span class="token function-variable function"${s}>component</span><span class="token operator"${s}>:</span> <span class="token punctuation"${s}>(</span><span class="token punctuation"${s}>)</span> <span class="token operator"${s}>=&gt;</span> <span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;pages/SomePage&#39;</span><span class="token punctuation"${s}>)</span>
  <span class="token punctuation"${s}>}</span>
<span class="token punctuation"${s}>]</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"const"),a(" routes "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"["),a(`
  `),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"path"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},"'/some-page'"),n("span",{class:"token punctuation"},","),a(`
    `),n("span",{class:"token function-variable function"},"component"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'pages/SomePage'"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"]")])]),n(o)]}),_:1},m,t)),p(`<p${t}>Easy, right? What this does is that it creates a separate chunk for <code class="doc-token"${t}>/src/pages/SomePage.vue</code> which is then loaded only when it is needed. In this case, when a user visits the ‘/some-page’ route.</p><h2 id="lazy-load-components" class="doc-heading doc-h2"${t}>Lazy-load components</h2><p${t}>Normally you would import a component and then register it to the Page, Layout or Component.</p>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token tag"${s}><span class="token tag"${s}><span class="token punctuation"${s}>&lt;</span>script</span><span class="token punctuation"${s}>&gt;</span></span><span class="token script"${s}><span class="token language-javascript"${s}>
<span class="token keyword"${s}>import</span> SomeComponent <span class="token keyword"${s}>from</span> <span class="token string"${s}>&#39;components/SomeComponent&#39;</span>

<span class="token keyword"${s}>export</span> <span class="token keyword"${s}>default</span> <span class="token punctuation"${s}>{</span>
  <span class="token literal-property property"${s}>components</span><span class="token operator"${s}>:</span> <span class="token punctuation"${s}>{</span>
    SomeComponent<span class="token punctuation"${s}>,</span>
  <span class="token punctuation"${s}>}</span>
<span class="token punctuation"${s}>}</span>
</span></span><span class="token tag"${s}><span class="token tag"${s}><span class="token punctuation"${s}>&lt;/</span>script</span><span class="token punctuation"${s}>&gt;</span></span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"<"),a("script")]),n("span",{class:"token punctuation"},">")]),n("span",{class:"token script"},[n("span",{class:"token language-javascript"},[a(`
`),n("span",{class:"token keyword"},"import"),a(" SomeComponent "),n("span",{class:"token keyword"},"from"),a(),n("span",{class:"token string"},"'components/SomeComponent'"),a(`

`),n("span",{class:"token keyword"},"export"),a(),n("span",{class:"token keyword"},"default"),a(),n("span",{class:"token punctuation"},"{"),a(`
  `),n("span",{class:"token literal-property property"},"components"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"{"),a(`
    SomeComponent`),n("span",{class:"token punctuation"},","),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])]),n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"</"),a("script")]),n("span",{class:"token punctuation"},">")])])]),n(o)]}),_:1},m,t)),p(`<p${t}>Now let’s change this and make the component be loaded on demand only, using dynamic imports:</p>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token tag"${s}><span class="token tag"${s}><span class="token punctuation"${s}>&lt;</span>script</span><span class="token punctuation"${s}>&gt;</span></span><span class="token script"${s}><span class="token language-javascript"${s}>
<span class="token keyword"${s}>import</span> <span class="token punctuation"${s}>{</span> defineAsyncComponent <span class="token punctuation"${s}>}</span> <span class="token keyword"${s}>from</span> <span class="token string"${s}>&#39;vue&#39;</span>
<span class="token keyword"${s}>export</span> <span class="token keyword"${s}>default</span> <span class="token punctuation"${s}>{</span>
  <span class="token literal-property property"${s}>components</span><span class="token operator"${s}>:</span> <span class="token punctuation"${s}>{</span>
    <span class="token literal-property property"${s}>SomeComponent</span><span class="token operator"${s}>:</span> <span class="token function"${s}>defineAsyncComponent</span><span class="token punctuation"${s}>(</span><span class="token punctuation"${s}>(</span><span class="token punctuation"${s}>)</span> <span class="token operator"${s}>=&gt;</span> <span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;components/SomeComponent&#39;</span><span class="token punctuation"${s}>)</span><span class="token punctuation"${s}>)</span><span class="token punctuation"${s}>,</span>
  <span class="token punctuation"${s}>}</span>
<span class="token punctuation"${s}>}</span>
</span></span><span class="token tag"${s}><span class="token tag"${s}><span class="token punctuation"${s}>&lt;/</span>script</span><span class="token punctuation"${s}>&gt;</span></span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"<"),a("script")]),n("span",{class:"token punctuation"},">")]),n("span",{class:"token script"},[n("span",{class:"token language-javascript"},[a(`
`),n("span",{class:"token keyword"},"import"),a(),n("span",{class:"token punctuation"},"{"),a(" defineAsyncComponent "),n("span",{class:"token punctuation"},"}"),a(),n("span",{class:"token keyword"},"from"),a(),n("span",{class:"token string"},"'vue'"),a(`
`),n("span",{class:"token keyword"},"export"),a(),n("span",{class:"token keyword"},"default"),a(),n("span",{class:"token punctuation"},"{"),a(`
  `),n("span",{class:"token literal-property property"},"components"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"SomeComponent"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token function"},"defineAsyncComponent"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'components/SomeComponent'"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},","),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])]),n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"</"),a("script")]),n("span",{class:"token punctuation"},">")])])]),n(o)]}),_:1},m,t)),p(`<h2 id="lazy-load-on-the-fly" class="doc-heading doc-h2"${t}>Lazy-load on the fly</h2><p${t}>As you noticed above, we’re using dynamic imports (<code class="doc-token"${t}>import(&#39;..resource..&#39;)</code>) instead of regular imports (<code class="doc-token"${t}>import Resource from &#39;./path/to/resource&#39;</code>). Dynamic imports are essentially returning a Promise that you can use:</p>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;./categories.json&#39;</span><span class="token punctuation"${s}>)</span>
  <span class="token punctuation"${s}>.</span><span class="token function"${s}>then</span><span class="token punctuation"${s}>(</span><span class="token parameter"${s}>categories</span> <span class="token operator"${s}>=&gt;</span> <span class="token punctuation"${s}>{</span>
    <span class="token comment"${s}>// hey, we have lazy loaded the file</span>
    <span class="token comment"${s}>// and we have its content in &quot;categories&quot;</span>
  <span class="token punctuation"${s}>}</span><span class="token punctuation"${s}>)</span>
  <span class="token punctuation"${s}>.</span><span class="token function"${s}>catch</span><span class="token punctuation"${s}>(</span><span class="token punctuation"${s}>(</span><span class="token punctuation"${s}>)</span> <span class="token operator"${s}>=&gt;</span> <span class="token punctuation"${s}>{</span>
    <span class="token comment"${s}>// oops, something went wrong...</span>
    <span class="token comment"${s}>// couldn&#39;t load the resource</span>
  <span class="token punctuation"${s}>}</span><span class="token punctuation"${s}>)</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./categories.json'"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"then"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},"categories"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token comment"},"// hey, we have lazy loaded the file"),a(`
    `),n("span",{class:"token comment"},'// and we have its content in "categories"'),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"catch"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token comment"},"// oops, something went wrong..."),a(`
    `),n("span",{class:"token comment"},"// couldn't load the resource"),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")")])]),n(o)]}),_:1},m,t)),p(`<p${t}>One advantage of using dynamic imports as opposed to regular imports is that the import path can be determined at runtime:</p>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;pages/&#39;</span> <span class="token operator"${s}>+</span> pageName <span class="token operator"${s}>+</span> <span class="token string"${s}>&#39;/&#39;</span> <span class="token operator"${s}>+</span> id<span class="token punctuation"${s}>)</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'pages/'"),a(),n("span",{class:"token operator"},"+"),a(" pageName "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token string"},"'/'"),a(),n("span",{class:"token operator"},"+"),a(" id"),n("span",{class:"token punctuation"},")")])]),n(o)]}),_:1},m,t)),p(`<h2 id="caveat-with-vendor-imports" class="doc-heading doc-h2"${t}>Caveat with vendor imports</h2><p${t}>By default, Quasar includes packages from <code class="doc-token"${t}>node_modules</code> in a vendor chunk even if your code imports them dynamically. This increases the vendor chunk size, but since you don’t usually change your dependencies, browsers will use the cached version of this chunk and actually speed up loading your app on subsequent visits.</p><p${t}>For example, if you have installed a package (let’s call it <code class="doc-token"${t}>my-package</code>) you can import it dynamically like this:</p>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;my-package&#39;</span><span class="token punctuation"${s}>)</span>
  <span class="token punctuation"${s}>.</span><span class="token function"${s}>then</span><span class="token punctuation"${s}>(</span><span class="token parameter"${s}>myPackage</span> <span class="token operator"${s}>=&gt;</span> <span class="token punctuation"${s}>{</span>
    <span class="token comment"${s}>// use the package</span>
  <span class="token punctuation"${s}>}</span><span class="token punctuation"${s}>)</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'my-package'"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"then"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},"myPackage"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token comment"},"// use the package"),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")")])]),n(o)]}),_:1},m,t)),p(`<p${t}>However, should you want to make Quasar CLI put <code class="doc-token"${t}>my-package</code> in its own chunk you’ll have to edit the <code class="doc-token"${t}>/quasar.config</code> file:</p>`),p(r(c(u),{title:"/quasar.config file"},{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token keyword"${s}>return</span> <span class="token punctuation"${s}>{</span>
  <span class="token literal-property property"${s}>vendor</span><span class="token operator"${s}>:</span> <span class="token punctuation"${s}>{</span>
    <span class="token literal-property property"${s}>remove</span><span class="token operator"${s}>:</span> <span class="token punctuation"${s}>[</span> <span class="token string"${s}>&#39;my-package&#39;</span> <span class="token punctuation"${s}>]</span>
  <span class="token punctuation"${s}>}</span>
<span class="token punctuation"${s}>}</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"return"),a(),n("span",{class:"token punctuation"},"{"),a(`
  `),n("span",{class:"token literal-property property"},"vendor"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"remove"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"["),a(),n("span",{class:"token string"},"'my-package'"),a(),n("span",{class:"token punctuation"},"]"),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}")])]),n(o)]}),_:1},m,t)),p(`<p${t}>For more details, see the `),p(r(d,{to:"/quasar-cli-webpack/quasar-config-file#property-vendor"},{default:l((k,e,i,s)=>{if(e)e("vendors section");else return[a("vendors section")]}),_:1},m,t)),p(` of the <code class="doc-token"${t}>/quasar.config</code> file.</p><h2 id="caveat-for-dynamic-imports" class="doc-heading doc-h2"${t}>Caveat for dynamic imports</h2><p${t}>There’s one caveat when using dynamic imports with variable parts like in the previous example. When the website/app is bundled, so at compile time, we have no way of telling what the exact import path will be at runtime. As a result, chunks will be created for each file that could match the variable path. You might see un-necessary files in the build log.</p><p${t}>So how can we limit the number of chunks created in this case? The idea is to limit the variable part as much as you can so the matched paths are as few as possible.</p><ol${t}><li${t}>Add file extension, even if it works without it too. This will create chunks only for that file types. Useful when that folder contains many file types.</li></ol>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token comment"${s}>// bad</span>
<span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;./folder/&#39;</span> <span class="token operator"${s}>+</span> pageName<span class="token punctuation"${s}>)</span>

<span class="token comment"${s}>// much better</span>
<span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;./folder/&#39;</span> <span class="token operator"${s}>+</span> pageName <span class="token operator"${s}>+</span> <span class="token string"${s}>&#39;.vue&#39;</span><span class="token punctuation"${s}>)</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token comment"},"// bad"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/'"),a(),n("span",{class:"token operator"},"+"),a(" pageName"),n("span",{class:"token punctuation"},")"),a(`

`),n("span",{class:"token comment"},"// much better"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/'"),a(),n("span",{class:"token operator"},"+"),a(" pageName "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token string"},"'.vue'"),n("span",{class:"token punctuation"},")")])]),n(o)]}),_:1},m,t)),p(`<ol start="2"${t}><li${t}>Try to create a folder structure that will limit the files available in that variable path. Make it as specific as possible:</li></ol>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token comment"${s}>// bad -- makes chunks for any JSON inside ./folder (recursive search)</span>
<span class="token keyword"${s}>const</span> asset <span class="token operator"${s}>=</span> <span class="token string"${s}>&#39;my/jsons/categories.json&#39;</span>
<span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;./folder/&#39;</span> <span class="token operator"${s}>+</span> asset<span class="token punctuation"${s}>)</span>

<span class="token comment"${s}>// good -- makes chunks only for JSONs inside ./folder/my/jsons</span>
<span class="token keyword"${s}>const</span> asset <span class="token operator"${s}>=</span> <span class="token string"${s}>&#39;categories.json&#39;</span>
<span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span><span class="token string"${s}>&#39;./folder/my/jsons/&#39;</span> <span class="token operator"${s}>+</span> asset<span class="token punctuation"${s}>)</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token comment"},"// bad -- makes chunks for any JSON inside ./folder (recursive search)"),a(`
`),n("span",{class:"token keyword"},"const"),a(" asset "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},"'my/jsons/categories.json'"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/'"),a(),n("span",{class:"token operator"},"+"),a(" asset"),n("span",{class:"token punctuation"},")"),a(`

`),n("span",{class:"token comment"},"// good -- makes chunks only for JSONs inside ./folder/my/jsons"),a(`
`),n("span",{class:"token keyword"},"const"),a(" asset "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},"'categories.json'"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/my/jsons/'"),a(),n("span",{class:"token operator"},"+"),a(" asset"),n("span",{class:"token punctuation"},")")])]),n(o)]}),_:1},m,t)),p(`<ol start="3"${t}><li${t}><p${t}>Try to import from folders containing only files. Take the previous example and imagine ./folder/my/jsons further contains sub-folders. We made the dynamic import better by specifying a more specific path, but it’s still not optimal in this case. Best is to use terminal folders that only contain files, so we limit the number of matched paths.</p></li><li${t}><p${t}>Use `),p(r(d,{to:"https://webpack.js.org/api/module-methods/#magic-comments"},{default:l((k,e,i,s)=>{if(e)e("Webpack magic comments");else return[a("Webpack magic comments")]}),_:1},m,t)),p(` <code class="doc-token"${t}>webpackInclude</code> and <code class="doc-token"${t}>webpackExclude</code> to constrain the bundled chunks with a regular expression, for example:</p></li></ol>`),p(r(c(u),null,{default:l((k,e,i,s)=>{if(e)e(`<pre class="doc-code"${s}><code${s}><span class="token keyword"${s}>await</span> <span class="token keyword"${s}>import</span><span class="token punctuation"${s}>(</span>
  <span class="token comment"${s}>/* webpackInclude: /(ar|en-US|ro)\\.js$/ */</span>
  <span class="token string"${s}>&#39;quasar/lang/&#39;</span> <span class="token operator"${s}>+</span> langIso
<span class="token punctuation"${s}>)</span>
  <span class="token punctuation"${s}>.</span><span class="token function"${s}>then</span><span class="token punctuation"${s}>(</span><span class="token parameter"${s}>lang</span> <span class="token operator"${s}>=&gt;</span> <span class="token punctuation"${s}>{</span>
    Quasar<span class="token punctuation"${s}>.</span>lang<span class="token punctuation"${s}>.</span><span class="token function"${s}>set</span><span class="token punctuation"${s}>(</span>lang<span class="token punctuation"${s}>.</span>default<span class="token punctuation"${s}>)</span>
  <span class="token punctuation"${s}>}</span><span class="token punctuation"${s}>)</span></code></pre>`),e(r(o,null,null,i,s));else return[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"await"),a(),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),a(`
  `),n("span",{class:"token comment"},"/* webpackInclude: /(ar|en-US|ro)\\.js$/ */"),a(`
  `),n("span",{class:"token string"},"'quasar/lang/'"),a(),n("span",{class:"token operator"},"+"),a(` langIso
`),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"then"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},"lang"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    Quasar`),n("span",{class:"token punctuation"},"."),a("lang"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"set"),n("span",{class:"token punctuation"},"("),a("lang"),n("span",{class:"token punctuation"},"."),a("default"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")")])]),n(o)]}),_:1},m,t)),p(`<p${t}>will result in bundling only the language packs you need for your site/app, instead of bundling all the language packs (more than 40!) which might hamper the performance of the commands <code class="doc-token"${t}>quasar dev</code> and <code class="doc-token"${t}>quasar build</code>.</p><p${t}>Remember that the number of matched paths equals to the number of chunks being generated.</p>`);else return[n("p",null,"When your website/app is small, you can load all layouts/pages/components into the initial bundle and serve everything at startup. But when your code gets complex and has many layouts/pages/components, it won’t be optimal to do this as it will massively impact loading time. Fortunately, there is a way to solve this."),n("p",null,"We’ll cover how you can lazy load / code split parts of your app so that they are automatically requested only on demand. This is done through dynamic imports. Let’s start with an example and then convert it so that we use lazy loading – we’ll focus this example on loading a page, but the same principle can be applied to load anything (assets, JSONs, …)."),n("h2",{id:"lazy-load-router-pages",class:"doc-heading doc-h2",onClick:k=>c(y)("lazy-load-router-pages")},"Lazy-load router pages",8,["onClick"]),n("p",null,"It’s normal to use the Vue Router calling static components as below."),n("div",{class:"doc-note doc-note--warning"},[n("p",{class:"doc-note__title"},"WARNING"),n("p",null,[a("Quasar documentation assumes you are already familiar with "),n(d,{to:"https://github.com/vuejs/vue-router"},{default:l(()=>[a("Vue Router")]),_:1}),a(". Below it’s described only the basics of how to make use of it in a Quasar CLI project. For the full list of its features please visit the "),n(d,{to:"https://router.vuejs.org/"},{default:l(()=>[a("Vue Router documentation")]),_:1}),a(".")])]),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),a(" SomePage "),n("span",{class:"token keyword"},"from"),a(),n("span",{class:"token string"},"'pages/SomePage'"),a(`

`),n("span",{class:"token keyword"},"const"),a(" routes "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"["),a(`
  `),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"path"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},"'/some-page'"),n("span",{class:"token punctuation"},","),a(`
    `),n("span",{class:"token literal-property property"},"component"),n("span",{class:"token operator"},":"),a(` SomePage
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"]")])]),n(o)]),_:1}),n("p",null,"Now let’s change this and make the page be loaded on demand only, using dynamic imports:"),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"const"),a(" routes "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"["),a(`
  `),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"path"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},"'/some-page'"),n("span",{class:"token punctuation"},","),a(`
    `),n("span",{class:"token function-variable function"},"component"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'pages/SomePage'"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"]")])]),n(o)]),_:1}),n("p",null,[a("Easy, right? What this does is that it creates a separate chunk for "),n("code",{class:"doc-token"},"/src/pages/SomePage.vue"),a(" which is then loaded only when it is needed. In this case, when a user visits the ‘/some-page’ route.")]),n("h2",{id:"lazy-load-components",class:"doc-heading doc-h2",onClick:k=>c(y)("lazy-load-components")},"Lazy-load components",8,["onClick"]),n("p",null,"Normally you would import a component and then register it to the Page, Layout or Component."),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"<"),a("script")]),n("span",{class:"token punctuation"},">")]),n("span",{class:"token script"},[n("span",{class:"token language-javascript"},[a(`
`),n("span",{class:"token keyword"},"import"),a(" SomeComponent "),n("span",{class:"token keyword"},"from"),a(),n("span",{class:"token string"},"'components/SomeComponent'"),a(`

`),n("span",{class:"token keyword"},"export"),a(),n("span",{class:"token keyword"},"default"),a(),n("span",{class:"token punctuation"},"{"),a(`
  `),n("span",{class:"token literal-property property"},"components"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"{"),a(`
    SomeComponent`),n("span",{class:"token punctuation"},","),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])]),n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"</"),a("script")]),n("span",{class:"token punctuation"},">")])])]),n(o)]),_:1}),n("p",null,"Now let’s change this and make the component be loaded on demand only, using dynamic imports:"),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"<"),a("script")]),n("span",{class:"token punctuation"},">")]),n("span",{class:"token script"},[n("span",{class:"token language-javascript"},[a(`
`),n("span",{class:"token keyword"},"import"),a(),n("span",{class:"token punctuation"},"{"),a(" defineAsyncComponent "),n("span",{class:"token punctuation"},"}"),a(),n("span",{class:"token keyword"},"from"),a(),n("span",{class:"token string"},"'vue'"),a(`
`),n("span",{class:"token keyword"},"export"),a(),n("span",{class:"token keyword"},"default"),a(),n("span",{class:"token punctuation"},"{"),a(`
  `),n("span",{class:"token literal-property property"},"components"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"SomeComponent"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token function"},"defineAsyncComponent"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'components/SomeComponent'"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},","),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])]),n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"</"),a("script")]),n("span",{class:"token punctuation"},">")])])]),n(o)]),_:1}),n("h2",{id:"lazy-load-on-the-fly",class:"doc-heading doc-h2",onClick:k=>c(y)("lazy-load-on-the-fly")},"Lazy-load on the fly",8,["onClick"]),n("p",null,[a("As you noticed above, we’re using dynamic imports ("),n("code",{class:"doc-token"},"import('..resource..')"),a(") instead of regular imports ("),n("code",{class:"doc-token"},"import Resource from './path/to/resource'"),a("). Dynamic imports are essentially returning a Promise that you can use:")]),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./categories.json'"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"then"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},"categories"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token comment"},"// hey, we have lazy loaded the file"),a(`
    `),n("span",{class:"token comment"},'// and we have its content in "categories"'),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"catch"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token comment"},"// oops, something went wrong..."),a(`
    `),n("span",{class:"token comment"},"// couldn't load the resource"),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")")])]),n(o)]),_:1}),n("p",null,"One advantage of using dynamic imports as opposed to regular imports is that the import path can be determined at runtime:"),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'pages/'"),a(),n("span",{class:"token operator"},"+"),a(" pageName "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token string"},"'/'"),a(),n("span",{class:"token operator"},"+"),a(" id"),n("span",{class:"token punctuation"},")")])]),n(o)]),_:1}),n("h2",{id:"caveat-with-vendor-imports",class:"doc-heading doc-h2",onClick:k=>c(y)("caveat-with-vendor-imports")},"Caveat with vendor imports",8,["onClick"]),n("p",null,[a("By default, Quasar includes packages from "),n("code",{class:"doc-token"},"node_modules"),a(" in a vendor chunk even if your code imports them dynamically. This increases the vendor chunk size, but since you don’t usually change your dependencies, browsers will use the cached version of this chunk and actually speed up loading your app on subsequent visits.")]),n("p",null,[a("For example, if you have installed a package (let’s call it "),n("code",{class:"doc-token"},"my-package"),a(") you can import it dynamically like this:")]),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'my-package'"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"then"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},"myPackage"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token comment"},"// use the package"),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")")])]),n(o)]),_:1}),n("p",null,[a("However, should you want to make Quasar CLI put "),n("code",{class:"doc-token"},"my-package"),a(" in its own chunk you’ll have to edit the "),n("code",{class:"doc-token"},"/quasar.config"),a(" file:")]),n(c(u),{title:"/quasar.config file"},{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"return"),a(),n("span",{class:"token punctuation"},"{"),a(`
  `),n("span",{class:"token literal-property property"},"vendor"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token literal-property property"},"remove"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"["),a(),n("span",{class:"token string"},"'my-package'"),a(),n("span",{class:"token punctuation"},"]"),a(`
  `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}")])]),n(o)]),_:1}),n("p",null,[a("For more details, see the "),n(d,{to:"/quasar-cli-webpack/quasar-config-file#property-vendor"},{default:l(()=>[a("vendors section")]),_:1}),a(" of the "),n("code",{class:"doc-token"},"/quasar.config"),a(" file.")]),n("h2",{id:"caveat-for-dynamic-imports",class:"doc-heading doc-h2",onClick:k=>c(y)("caveat-for-dynamic-imports")},"Caveat for dynamic imports",8,["onClick"]),n("p",null,"There’s one caveat when using dynamic imports with variable parts like in the previous example. When the website/app is bundled, so at compile time, we have no way of telling what the exact import path will be at runtime. As a result, chunks will be created for each file that could match the variable path. You might see un-necessary files in the build log."),n("p",null,"So how can we limit the number of chunks created in this case? The idea is to limit the variable part as much as you can so the matched paths are as few as possible."),n("ol",null,[n("li",null,"Add file extension, even if it works without it too. This will create chunks only for that file types. Useful when that folder contains many file types.")]),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token comment"},"// bad"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/'"),a(),n("span",{class:"token operator"},"+"),a(" pageName"),n("span",{class:"token punctuation"},")"),a(`

`),n("span",{class:"token comment"},"// much better"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/'"),a(),n("span",{class:"token operator"},"+"),a(" pageName "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token string"},"'.vue'"),n("span",{class:"token punctuation"},")")])]),n(o)]),_:1}),n("ol",{start:"2"},[n("li",null,"Try to create a folder structure that will limit the files available in that variable path. Make it as specific as possible:")]),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token comment"},"// bad -- makes chunks for any JSON inside ./folder (recursive search)"),a(`
`),n("span",{class:"token keyword"},"const"),a(" asset "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},"'my/jsons/categories.json'"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/'"),a(),n("span",{class:"token operator"},"+"),a(" asset"),n("span",{class:"token punctuation"},")"),a(`

`),n("span",{class:"token comment"},"// good -- makes chunks only for JSONs inside ./folder/my/jsons"),a(`
`),n("span",{class:"token keyword"},"const"),a(" asset "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},"'categories.json'"),a(`
`),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},"'./folder/my/jsons/'"),a(),n("span",{class:"token operator"},"+"),a(" asset"),n("span",{class:"token punctuation"},")")])]),n(o)]),_:1}),n("ol",{start:"3"},[n("li",null,[n("p",null,"Try to import from folders containing only files. Take the previous example and imagine ./folder/my/jsons further contains sub-folders. We made the dynamic import better by specifying a more specific path, but it’s still not optimal in this case. Best is to use terminal folders that only contain files, so we limit the number of matched paths.")]),n("li",null,[n("p",null,[a("Use "),n(d,{to:"https://webpack.js.org/api/module-methods/#magic-comments"},{default:l(()=>[a("Webpack magic comments")]),_:1}),a(),n("code",{class:"doc-token"},"webpackInclude"),a(" and "),n("code",{class:"doc-token"},"webpackExclude"),a(" to constrain the bundled chunks with a regular expression, for example:")])])]),n(c(u),null,{default:l(()=>[n("pre",{class:"doc-code"},[n("code",null,[n("span",{class:"token keyword"},"await"),a(),n("span",{class:"token keyword"},"import"),n("span",{class:"token punctuation"},"("),a(`
  `),n("span",{class:"token comment"},"/* webpackInclude: /(ar|en-US|ro)\\.js$/ */"),a(`
  `),n("span",{class:"token string"},"'quasar/lang/'"),a(),n("span",{class:"token operator"},"+"),a(` langIso
`),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"then"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},"lang"),a(),n("span",{class:"token operator"},"=>"),a(),n("span",{class:"token punctuation"},"{"),a(`
    Quasar`),n("span",{class:"token punctuation"},"."),a("lang"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"set"),n("span",{class:"token punctuation"},"("),a("lang"),n("span",{class:"token punctuation"},"."),a("default"),n("span",{class:"token punctuation"},")"),a(`
  `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")")])]),n(o)]),_:1}),n("p",null,[a("will result in bundling only the language packs you need for your site/app, instead of bundling all the language packs (more than 40!) which might hamper the performance of the commands "),n("code",{class:"doc-token"},"quasar dev"),a(" and "),n("code",{class:"doc-token"},"quasar build"),a(".")]),n("p",null,"Remember that the number of matched paths equals to the number of chunks being generated.")]}),_:1},b))}}},w=$.setup;$.setup=(f,g)=>{const h=j();return(h.modules||(h.modules=new Set)).add("src/pages/quasar-cli-webpack/lazy-loading.md"),w?w(f,g):void 0};const U=x($,[["__file","lazy-loading.md"]]);export{U as default};
