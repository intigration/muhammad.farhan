import{provide as T,mergeProps as S,withCtx as u,createTextVNode as o,createVNode as t,unref as d,useSSRContext as O}from"vue";import{ssrRenderComponent as n}from"vue/server-renderer";import{c}from"./page-utils-C-QWsEHe.js";import{D as A,a as h}from"./DocPage-DKr-0pQn.js";import{D as i}from"./DocExample-BcaABDtE.js";import{D as b}from"./DocApi-Df9ryd6x.js";import{_ as N}from"../server-entry.js";import"quasar";import"@quasar/extras/mdi-v6";import"@quasar/extras/fontawesome-v6";import"@quasar/extras/mdi-v7";import"./DocCode-BVg0tuSc.js";import"prismjs";import"./CopyButton-l3ndfN49.js";import"./DocCodepen-BPVszLIH.js";import"./utils-DKnLoYai.js";import"./DocCardTitle-BSnqQsiz.js";import"vue-router";import"@quasar/extras/fontawesome-v5";import"quasar/icon-set/svg-mdi-v6.mjs";const f={__name:"select",__ssrInlineRender:!0,setup(g){T("_q_ex",{name:"QSelect"});const p=[{id:"qselect-api",title:"2. QSelect API",deep:!0},{id:"design",title:"3. Design"},{id:"overview",title:"3.1. Overview",sub:!0},{id:"decorators",title:"3.2. Decorators",sub:!0},{id:"coloring",title:"3.3. Coloring",sub:!0},{id:"clearable",title:"3.4. Clearable",sub:!0},{id:"disable-and-readonly",title:"3.5. Disable and readonly",sub:!0},{id:"slots-with-qbtn-type-submit",title:"3.6. Slots with QBtn type “submit”",sub:!0},{id:"menu-transitions",title:"3.7. Menu transitions",sub:!0},{id:"options-list-display-mode",title:"3.8. Options list display mode",sub:!0},{id:"the-model",title:"4. The model"},{id:"the-options",title:"5. The options"},{id:"options-type",title:"5.1. Options type",sub:!0},{id:"affecting-model",title:"5.2. Affecting model",sub:!0},{id:"custom-prop-names",title:"5.3. Custom prop names",sub:!0},{id:"customizing-menu-options",title:"5.4. Customizing menu options",sub:!0},{id:"lazy-loading",title:"5.5. Lazy loading",sub:!0},{id:"cover-mode",title:"5.6. Cover mode",sub:!0},{id:"the-display-value",title:"6. The display value"},{id:"filtering-and-autocomplete",title:"7. Filtering and autocomplete"},{id:"native-attributes-with-use-input",title:"7.1. Native attributes with “use-input”",sub:!0},{id:"create-new-values",title:"8. Create new values"},{id:"the-new-value-mode-prop",title:"8.1. The new-value-mode prop",sub:!0},{id:"the-new-value-event",title:"8.2. The @new-value event",sub:!0},{id:"using-menu-and-filtering",title:"8.3. Using menu and filtering",sub:!0},{id:"sanitization",title:"9. Sanitization"},{id:"render-performance",title:"10. Render performance"},{id:"keyboard-navigation",title:"11. Keyboard navigation"},{id:"native-form-submit",title:"12. Native form submit"}];return(m,y,$,C)=>{y(n(A,S({title:"Select",desc:"The QSelect Vue component has two types of selection - single or multiple. This component opens up a menu for the selection list and action. A filter can also be used for longer lists.",heading:"","edit-link":"vue-components/select",toc:p},C),{default:u((Q,l,a,e)=>{if(l)l(`<p${e}>The QSelect component has two types of selection: single or multiple. This component opens up a menu for the selection list and action. A filter can also be used for longer lists.</p><p${e}>In case you are looking for a dropdown “button” instead of “input” use `),l(n(h,{to:"/vue-components/button-dropdown"},{default:u((s,r,v,k)=>{if(r)r("Button Dropdown");else return[o("Button Dropdown")]}),_:1},a,e)),l(" instead.</p>"),l(n(b,{file:"QSelect"},null,a,e)),l(`<h2 id="design" class="doc-heading doc-h2"${e}>Design</h2><h3 id="overview" class="doc-heading doc-h3"${e}>Overview</h3><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>For your QSelect you can use only one of the main designs (<code class="doc-token"${e}>filled</code>, <code class="doc-token"${e}>outlined</code>, <code class="doc-token"${e}>standout</code>, <code class="doc-token"${e}>borderless</code>). You cannot use multiple as they are self-exclusive.</p></div>`),l(n(i,{title:"Design Overview",file:"DesignOverview"},null,a,e)),l(`<h3 id="decorators" class="doc-heading doc-h3"${e}>Decorators</h3>`),l(n(i,{title:"Decorators",file:"Decorators"},null,a,e)),l(`<h3 id="coloring" class="doc-heading doc-h3"${e}>Coloring</h3>`),l(n(i,{title:"Coloring",file:"Coloring"},null,a,e)),l(`<h3 id="clearable" class="doc-heading doc-h3"${e}>Clearable</h3><p${e}>As a helper, you can use <code class="doc-token"${e}>clearable</code> prop so user can reset model to <code class="doc-token"${e}>null</code> through an appended icon. The second QSelect in the example below is the equivalent of using <code class="doc-token"${e}>clearable</code>.</p>`),l(n(i,{title:"Clearable",file:"Clearable"},null,a,e)),l(`<h3 id="disable-and-readonly" class="doc-heading doc-h3"${e}>Disable and readonly</h3>`),l(n(i,{title:"Disable and readonly",file:"DisableReadonly"},null,a,e)),l(`<h3 id="slots-with-qbtn-type-submit" class="doc-heading doc-h3"${e}>Slots with QBtn type “submit”</h3><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>When placing a QBtn with type “submit” in one of the “before”, “after”, “prepend”, or “append” slots of a QField, QInput or QSelect, you should also add a <code class="doc-token"${e}>@click</code> listener on the QBtn in question. This listener should call the method that submits your form. All “click” events in such slots are not propagated to their parent elements.</p></div><h3 id="menu-transitions" class="doc-heading doc-h3"${e}>Menu transitions</h3><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>Please note that transitions do not work when using <code class="doc-token"${e}>options-cover</code> prop.</p></div><p${e}>In the example below there’s a few transitions showcased. For a full list of transitions available, go to `),l(n(h,{to:"/options/transitions"},{default:u((s,r,v,k)=>{if(r)r("Transitions");else return[o("Transitions")]}),_:1},a,e)),l(".</p>"),l(n(i,{title:"Menu transitions",file:"MenuTransitions"},null,a,e)),l(`<h3 id="options-list-display-mode" class="doc-heading doc-h3"${e}>Options list display mode</h3><p${e}>By default QSelect shows the list of options as a menu on desktop and as a dialog on mobiles. You can force one behavior by using the <code class="doc-token"${e}>behavior</code> property.</p><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>Please note that on iOS menu behavior might generate problems, especially when used in combination with <code class="doc-token"${e}>use-input</code> prop. You can use a conditional <code class="doc-token"${e}>behavior</code> prop like <code class="doc-token"${e}>:behavior=&quot;$q.platform.is.ios === true ? &#39;dialog&#39; : &#39;menu&#39;&quot;</code> to use dialog mode only on iOS.</p></div>`),l(n(i,{title:"Show options in menu",file:"BehaviorMenu"},null,a,e)),l(n(i,{title:"Show options in dialog",file:"BehaviorDialog"},null,a,e)),l(`<h2 id="the-model" class="doc-heading doc-h2"${e}>The model</h2><div class="doc-note doc-note--danger"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>The model for single selection can be anything (String, Object, …) while the model for multiple selection must be an Array.</p></div>`),l(n(i,{title:"Single vs multiple selection",file:"ModelSingleMultiple"},null,a,e)),l(n(i,{title:"Multiple selection, counter and max-values",file:"ModelMultipleCounter"},null,a,e)),l(`<p${e}>The model content can be influenced by <code class="doc-token"${e}>emit-value</code> prop as you’ll learn in “The options” section below.</p><h2 id="the-options" class="doc-heading doc-h2"${e}>The options</h2><h3 id="options-type" class="doc-heading doc-h3"${e}>Options type</h3>`),l(n(i,{title:"String options",file:"OptionString"},null,a,e)),l(n(i,{title:"Object options",file:"OptionObject"},null,a,e)),l(`<h3 id="affecting-model" class="doc-heading doc-h3"${e}>Affecting model</h3><p${e}>When <code class="doc-token"${e}>emit-value</code> is used, the model becomes the determined <code class="doc-token"${e}>value</code> from the specified selected option. Default is to emit the whole option. It makes sense to use it only when the options are of Object form.</p>`),l(n(i,{title:"Emit-value",file:"OptionEmitValue"},null,a,e)),l(`<p${e}>When <code class="doc-token"${e}>map-options</code> is used, the model can contain only the <code class="doc-token"${e}>value</code>, and it will be mapped against the options to determine its label. There is a performance penalty involved, so use it only if absolutely necessary. It’s not needed, for example, if the model contains the whole Object (so contains the label prop).</p>`),l(n(i,{title:"Map options",file:"OptionMapOptions"},null,a,e)),l(`<h3 id="custom-prop-names" class="doc-heading doc-h3"${e}>Custom prop names</h3><p${e}>By default, QSelect looks at <code class="doc-token"${e}>label</code>, <code class="doc-token"${e}>value</code>, <code class="doc-token"${e}>disable</code> and <code class="doc-token"${e}>sanitize</code> props of each option from the options array Objects. But you can override those:</p><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>If you use functions for custom props always check if the option is null. These functions are used both for options in the list and for the selected options.</p></div>`),l(n(i,{title:"Custom label, value and disable props",file:"OptionCustomProps"},null,a,e)),l(`<h3 id="customizing-menu-options" class="doc-heading doc-h3"${e}>Customizing menu options</h3><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>The list of options is rendered using virtual scroll, so if you render more than one element for an option you must set a <code class="doc-token"${e}>q-virtual-scroll--with-prev</code> class on all elements except the first one.</p></div>`),l(n(i,{title:"Options slot",file:"OptionSlot"},null,a,e)),l(`<p${e}>Here is another example where we add a QToggle to each option. The possibilities are endless.</p>`),l(n(i,{title:"Object options",file:"OptionQToggle"},null,a,e)),l(`<p${e}>By default, when there are no options, the menu won’t appear. But you can customize this scenario and specify what the menu should display.</p>`),l(n(i,{title:"No options slot",file:"OptionNoneSlot"},null,a,e)),l(`<h3 id="lazy-loading" class="doc-heading doc-h3"${e}>Lazy loading</h3><p${e}>The following example shows a glimpse of how you can play with lazy loading the options. This means, along with many other things, that <code class="doc-token"${e}>options</code> prop is not required on first render.</p>`),l(n(i,{title:"Lazy load options",file:"OptionLazyLoad"},null,a,e)),l(`<p${e}>You can dynamically load new options when scroll reaches the end:</p>`),l(n(i,{title:"Dynamic loading options",file:"OptionsDynamic"},null,a,e)),l(`<h3 id="cover-mode" class="doc-heading doc-h3"${e}>Cover mode</h3>`),l(n(i,{title:"Menu covering component",file:"OptionCover"},null,a,e)),l(`<h2 id="the-display-value" class="doc-heading doc-h2"${e}>The display value</h2>`),l(n(i,{title:"Custom display value",file:"DisplayCustomValue"},null,a,e)),l(n(i,{title:"Chips as display value",file:"DisplayChips"},null,a,e)),l(n(i,{title:"Selected-item slot",file:"DisplaySelectedItemSlot"},null,a,e)),l(`<h2 id="filtering-and-autocomplete" class="doc-heading doc-h2"${e}>Filtering and autocomplete</h2><h3 id="native-attributes-with-use-input" class="doc-heading doc-h3"${e}>Native attributes with “use-input”</h3><p${e}>All the attributes set on QSelect that are not in the list of props in the API will be passed to the native input field used (please check <code class="doc-token"${e}>use-input</code> prop description first to understand what it does) for filtering / autocomplete / adding new value. Some examples: autocomplete, placeholder.</p><p${e}>More information: `),l(n(h,{to:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input"},{default:u((s,r,v,k)=>{if(r)r("native input attributes");else return[o("native input attributes")]}),_:1},a,e)),l(".</p>"),l(n(i,{title:"Filtering options",file:"InputFilterOptions"},null,a,e)),l(n(i,{title:"Basic filtering",file:"BasicFiltering"},null,a,e)),l(n(i,{title:"Filtering on more than 2 chars",file:"InputFilterMin"},null,a,e)),l(n(i,{title:"Text autocomplete",file:"TextAutocomplete"},null,a,e)),l(n(i,{title:"Lazy filtering",file:"InputFilterLazy"},null,a,e)),l(n(i,{title:"Selecting option after filtering",file:"InputFilterAfter"},null,a,e)),l(`<h2 id="create-new-values" class="doc-heading doc-h2"${e}>Create new values</h2><div class="doc-note doc-note--tip"${e}><p class="doc-note__title"${e}>TIP</p><p${e}>The following are just a few examples to get you started into making your own QSelect behavior. This is not exhaustive list of possibilities that QSelect offers.</p><p${e}>It makes sense to use this feature along with <code class="doc-token"${e}>use-input</code> prop.</p></div><p${e}>In order to enable the creation of new values, you need to <strong${e}>either specify</strong> the <code class="doc-token"${e}>new-value-mode</code> prop <strong${e}>and/or</strong> listen for <code class="doc-token"${e}>@new-value</code> event. If you use both, then the purpose of listening to <code class="doc-token"${e}>@new-value</code> would be only to override the <code class="doc-token"${e}>new-value-mode</code> in your custom scenarios.</p><h3 id="the-new-value-mode-prop" class="doc-heading doc-h3"${e}>The new-value-mode prop</h3><p${e}>The <code class="doc-token"${e}>new-value-mode</code> prop value specifies how the value should be added: <code class="doc-token"${e}>add</code> (adds a value, even if duplicate), <code class="doc-token"${e}>add-unique</code> (add only if NOT duplicate) or <code class="doc-token"${e}>toggle</code> (adds value if it’s not already in model, otherwise it removes it).</p><p${e}>By using this prop you don’t need to also listen for <code class="doc-token"${e}>@new-value</code> event, unless you have some specific scenarios for which you want to override the behavior.</p>`),l(n(i,{title:"New value mode",file:"CreateNewValueMode"},null,a,e)),l(`<h3 id="the-new-value-event" class="doc-heading doc-h3"${e}>The @new-value event</h3><p${e}>The <code class="doc-token"${e}>@new-value</code> event is emitted with the value to be added and a <code class="doc-token"${e}>done</code> callback. The <code class="doc-token"${e}>done</code> callback has two <strong${e}>optional</strong> parameters:</p><ul${e}><li${e}>the value to be added</li><li${e}>the behavior (same values of <code class="doc-token"${e}>new-value-mode</code> prop, and when it is specified it overrides that prop – if it is used) – default behavior (if not using <code class="doc-token"${e}>new-value-mode</code>) is to add the value even if it would be a duplicate</li></ul><p${e}>Calling <code class="doc-token"${e}>done()</code> with no parameters simply empties the input box value, without tampering with the model in any way.</p>`),l(n(i,{title:"Listening on @new-value",file:"CreateListener"},null,a,e)),l(n(i,{title:"Adding only unique values",file:"CreateListenerUnique"},null,a,e)),l(`<h3 id="using-menu-and-filtering" class="doc-heading doc-h3"${e}>Using menu and filtering</h3><p${e}>Filtering and adding the new values to menu:</p>`),l(n(i,{title:"Filtering and adding to menu",file:"FilteringAddsToMenu"},null,a,e)),l(`<p${e}>Filters new values (in the example below the value to be added requires at least 3 characters to pass), and does not add to menu:</p>`),l(n(i,{title:"Filtering without adding to menu",file:"FilteringNoAddToMenu"},null,a,e)),l(`<p${e}>Generating multiple values from input:</p>`),l(n(i,{title:"Generating multiple values",file:"FilteringAddMultiple"},null,a,e)),l(`<h2 id="sanitization" class="doc-heading doc-h2"${e}>Sanitization</h2><p${e}><strong${e}>By default, all options (included selected ones) are sanitized</strong>. This means that displaying them in HTML format is disabled. However, if you require HTML on your options and you trust their content, then there are a few ways to do this.</p><p${e}>You can force the HTML form of the menu options by:</p><ul${e}><li${e}>setting <code class="doc-token"${e}>html</code> key of the trusted option to <code class="doc-token"${e}>true</code> (for specific trusted options)</li><li${e}>or by setting <code class="doc-token"${e}>options-html</code> prop of QSelect (for all options)</li></ul><p${e}>The displayed value of QSelect is displayed as HTML if:</p><ul${e}><li${e}>the <code class="doc-token"${e}>display-value-html</code> prop of QSelect is set</li><li${e}>or you are not using <code class="doc-token"${e}>display-value</code> and <ul${e}><li${e}>the <code class="doc-token"${e}>options-html</code> prop of QSelect is set</li><li${e}>any selected option has <code class="doc-token"${e}>html</code> key set to <code class="doc-token"${e}>true</code></li></ul></li></ul><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>If you use <code class="doc-token"${e}>selected</code> or <code class="doc-token"${e}>selected-item</code> slots, then you are responsible for sanitization of the display value. The <code class="doc-token"${e}>display-value-html</code> prop will not apply.</p></div>`),l(n(i,{title:"Options in HTML form",file:"HtmlOptions"},null,a,e)),l(n(i,{title:"Display value in HTML form",file:"HtmlDisplayValue"},null,a,e)),l(`<h2 id="render-performance" class="doc-heading doc-h2"${e}>Render performance</h2><p${e}>The render performance is NOT affected much by the number of options, unless <code class="doc-token"${e}>map-options</code> is used on a large set. Notice the infinite scroll in place which renders additional options as the user scrolls through the list.</p><div class="doc-note doc-note--tip"${e}><p class="doc-note__title"${e}>TIP</p><ul${e}><li${e}>(Composition API) To get the best performance while using lots of options, do not wrap the array that you are passing in the <code class="doc-token"${e}>options</code> prop with ref()/computed()/reactive()/etc. This allows Vue to skip making the list “responsive” to changes.</li><li${e}>(Options API) To get the best performance while using lots of options, freeze the array that you are passing in the <code class="doc-token"${e}>options</code> prop using <code class="doc-token"${e}>Object.freeze(items)</code>. This allows Vue to skip making the list “responsive” to changes.</li></ul></div>`),l(n(i,{title:"100k options",file:"RenderPerf"},null,a,e)),l(`<h2 id="keyboard-navigation" class="doc-heading doc-h2"${e}>Keyboard navigation</h2><p${e}>When QSelect is focused:</p><ul${e}><li${e}>pressing <kbd${e}>ENTER</kbd>, <kbd${e}>ARROW DOWN</kbd> (or <kbd${e}>SPACE</kbd> if <code class="doc-token"${e}>use-input</code> is not set) will open the list of options</li><li${e}>if <code class="doc-token"${e}>use-chips</code> is set: <ul${e}><li${e}>pressing <kbd${e}>SHIFT</kbd> + <kbd${e}>TAB</kbd> will navigate backwards through the QChips (if a QChip is selected <kbd${e}>TAB</kbd> will navigate forward through the QChips)</li><li${e}>pressing <kbd${e}>ENTER</kbd> when a QChip is selected will remove that option from the selection</li><li${e}>pressing <kbd${e}>BACKSPACE</kbd> will remove the last option from the selection (when <code class="doc-token"${e}>use-input</code> is set the input should be empty)</li></ul></li><li${e}>pressing <kbd${e}>BACKSPACE</kbd> when <code class="doc-token"${e}>clearable</code> is set then: <ul${e}><li${e}>it clears the model (with <code class="doc-token"${e}>null</code> value) for single selection</li><li${e}>it removes the last added value for multiple selection</li></ul></li><li${e}>pressing <kbd${e}>TAB</kbd> (or <kbd${e}>SHIFT</kbd> + <kbd${e}>TAB</kbd> if <code class="doc-token"${e}>use-chips</code> is not set or the first QChip is selected) will navigate to the next or previous focusable element on page</li><li${e}>typing text (<kbd${e}>0</kbd> - <kbd${e}>9</kbd> or <kbd${e}>A</kbd> - <kbd${e}>Z</kbd>) if <code class="doc-token"${e}>use-input</code> is not set will: <ul${e}><li${e}>create a search buffer (will be reset when a new key is not typed for 1.5 seconds) that will be used to search in the options labels</li><li${e}>select the next option starting with that letter (after the current focused one) if the first key in buffer is typed multiple times</li><li${e}>select the next option (starting with the current focused one) that matches the typed text (the match is fuzzy - the option label should start with the first letter and contain all the letters)</li></ul></li></ul><p${e}>When the list of options is opened:</p><ul${e}><li${e}>pressing <kbd${e}>ARROW UP</kbd> or <kbd${e}>ARROW DOWN</kbd> will navigate up or down in the list of options</li><li${e}>pressing <kbd${e}>PAGE UP</kbd> or <kbd${e}>PAGE DOWN</kbd> will navigate one page up or down in the list of options</li><li${e}>pressing <kbd${e}>HOME</kbd> or <kbd${e}>END</kbd> will navigate to the start or end of the list of options (only if you are not using <code class="doc-token"${e}>use-input</code>, or the input is empty)</li><li${e}>when navigating using arrow keys, navigation will wrap when reaching the start or end of the list</li><li${e}>pressing <kbd${e}>ENTER</kbd> (or <kbd${e}>SPACE</kbd> when <code class="doc-token"${e}>use-input</code> is not set, or <kbd${e}>TAB</kbd> when <code class="doc-token"${e}>multiple</code> is not set) when an option is selected in the list will: <ul${e}><li${e}>select the option and close the list of options if <code class="doc-token"${e}>multiple</code> is not set</li><li${e}>toggle the option if <code class="doc-token"${e}>multiple</code> is set</li></ul></li></ul><h2 id="native-form-submit" class="doc-heading doc-h2"${e}>Native form submit</h2><p${e}>When dealing with a native form which has an <code class="doc-token"${e}>action</code> and a <code class="doc-token"${e}>method</code> (eg. when using Quasar with ASP.NET controllers), you need to specify the <code class="doc-token"${e}>name</code> property on QSelect, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):</p>`),l(n(i,{title:"Native form",file:"NativeForm"},null,a,e));else return[t("p",null,"The QSelect component has two types of selection: single or multiple. This component opens up a menu for the selection list and action. A filter can also be used for longer lists."),t("p",null,[o("In case you are looking for a dropdown “button” instead of “input” use "),t(h,{to:"/vue-components/button-dropdown"},{default:u(()=>[o("Button Dropdown")]),_:1}),o(" instead.")]),t(b,{file:"QSelect"}),t("h2",{id:"design",class:"doc-heading doc-h2",onClick:s=>d(c)("design")},"Design",8,["onClick"]),t("h3",{id:"overview",class:"doc-heading doc-h3",onClick:s=>d(c)("overview")},"Overview",8,["onClick"]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("For your QSelect you can use only one of the main designs ("),t("code",{class:"doc-token"},"filled"),o(", "),t("code",{class:"doc-token"},"outlined"),o(", "),t("code",{class:"doc-token"},"standout"),o(", "),t("code",{class:"doc-token"},"borderless"),o("). You cannot use multiple as they are self-exclusive.")])]),t(i,{title:"Design Overview",file:"DesignOverview"}),t("h3",{id:"decorators",class:"doc-heading doc-h3",onClick:s=>d(c)("decorators")},"Decorators",8,["onClick"]),t(i,{title:"Decorators",file:"Decorators"}),t("h3",{id:"coloring",class:"doc-heading doc-h3",onClick:s=>d(c)("coloring")},"Coloring",8,["onClick"]),t(i,{title:"Coloring",file:"Coloring"}),t("h3",{id:"clearable",class:"doc-heading doc-h3",onClick:s=>d(c)("clearable")},"Clearable",8,["onClick"]),t("p",null,[o("As a helper, you can use "),t("code",{class:"doc-token"},"clearable"),o(" prop so user can reset model to "),t("code",{class:"doc-token"},"null"),o(" through an appended icon. The second QSelect in the example below is the equivalent of using "),t("code",{class:"doc-token"},"clearable"),o(".")]),t(i,{title:"Clearable",file:"Clearable"}),t("h3",{id:"disable-and-readonly",class:"doc-heading doc-h3",onClick:s=>d(c)("disable-and-readonly")},"Disable and readonly",8,["onClick"]),t(i,{title:"Disable and readonly",file:"DisableReadonly"}),t("h3",{id:"slots-with-qbtn-type-submit",class:"doc-heading doc-h3",onClick:s=>d(c)("slots-with-qbtn-type-submit")},"Slots with QBtn type “submit”",8,["onClick"]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("When placing a QBtn with type “submit” in one of the “before”, “after”, “prepend”, or “append” slots of a QField, QInput or QSelect, you should also add a "),t("code",{class:"doc-token"},"@click"),o(" listener on the QBtn in question. This listener should call the method that submits your form. All “click” events in such slots are not propagated to their parent elements.")])]),t("h3",{id:"menu-transitions",class:"doc-heading doc-h3",onClick:s=>d(c)("menu-transitions")},"Menu transitions",8,["onClick"]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("Please note that transitions do not work when using "),t("code",{class:"doc-token"},"options-cover"),o(" prop.")])]),t("p",null,[o("In the example below there’s a few transitions showcased. For a full list of transitions available, go to "),t(h,{to:"/options/transitions"},{default:u(()=>[o("Transitions")]),_:1}),o(".")]),t(i,{title:"Menu transitions",file:"MenuTransitions"}),t("h3",{id:"options-list-display-mode",class:"doc-heading doc-h3",onClick:s=>d(c)("options-list-display-mode")},"Options list display mode",8,["onClick"]),t("p",null,[o("By default QSelect shows the list of options as a menu on desktop and as a dialog on mobiles. You can force one behavior by using the "),t("code",{class:"doc-token"},"behavior"),o(" property.")]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("Please note that on iOS menu behavior might generate problems, especially when used in combination with "),t("code",{class:"doc-token"},"use-input"),o(" prop. You can use a conditional "),t("code",{class:"doc-token"},"behavior"),o(" prop like "),t("code",{class:"doc-token"},`:behavior="$q.platform.is.ios === true ? 'dialog' : 'menu'"`),o(" to use dialog mode only on iOS.")])]),t(i,{title:"Show options in menu",file:"BehaviorMenu"}),t(i,{title:"Show options in dialog",file:"BehaviorDialog"}),t("h2",{id:"the-model",class:"doc-heading doc-h2",onClick:s=>d(c)("the-model")},"The model",8,["onClick"]),t("div",{class:"doc-note doc-note--danger"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,"The model for single selection can be anything (String, Object, …) while the model for multiple selection must be an Array.")]),t(i,{title:"Single vs multiple selection",file:"ModelSingleMultiple"}),t(i,{title:"Multiple selection, counter and max-values",file:"ModelMultipleCounter"}),t("p",null,[o("The model content can be influenced by "),t("code",{class:"doc-token"},"emit-value"),o(" prop as you’ll learn in “The options” section below.")]),t("h2",{id:"the-options",class:"doc-heading doc-h2",onClick:s=>d(c)("the-options")},"The options",8,["onClick"]),t("h3",{id:"options-type",class:"doc-heading doc-h3",onClick:s=>d(c)("options-type")},"Options type",8,["onClick"]),t(i,{title:"String options",file:"OptionString"}),t(i,{title:"Object options",file:"OptionObject"}),t("h3",{id:"affecting-model",class:"doc-heading doc-h3",onClick:s=>d(c)("affecting-model")},"Affecting model",8,["onClick"]),t("p",null,[o("When "),t("code",{class:"doc-token"},"emit-value"),o(" is used, the model becomes the determined "),t("code",{class:"doc-token"},"value"),o(" from the specified selected option. Default is to emit the whole option. It makes sense to use it only when the options are of Object form.")]),t(i,{title:"Emit-value",file:"OptionEmitValue"}),t("p",null,[o("When "),t("code",{class:"doc-token"},"map-options"),o(" is used, the model can contain only the "),t("code",{class:"doc-token"},"value"),o(", and it will be mapped against the options to determine its label. There is a performance penalty involved, so use it only if absolutely necessary. It’s not needed, for example, if the model contains the whole Object (so contains the label prop).")]),t(i,{title:"Map options",file:"OptionMapOptions"}),t("h3",{id:"custom-prop-names",class:"doc-heading doc-h3",onClick:s=>d(c)("custom-prop-names")},"Custom prop names",8,["onClick"]),t("p",null,[o("By default, QSelect looks at "),t("code",{class:"doc-token"},"label"),o(", "),t("code",{class:"doc-token"},"value"),o(", "),t("code",{class:"doc-token"},"disable"),o(" and "),t("code",{class:"doc-token"},"sanitize"),o(" props of each option from the options array Objects. But you can override those:")]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,"If you use functions for custom props always check if the option is null. These functions are used both for options in the list and for the selected options.")]),t(i,{title:"Custom label, value and disable props",file:"OptionCustomProps"}),t("h3",{id:"customizing-menu-options",class:"doc-heading doc-h3",onClick:s=>d(c)("customizing-menu-options")},"Customizing menu options",8,["onClick"]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("The list of options is rendered using virtual scroll, so if you render more than one element for an option you must set a "),t("code",{class:"doc-token"},"q-virtual-scroll--with-prev"),o(" class on all elements except the first one.")])]),t(i,{title:"Options slot",file:"OptionSlot"}),t("p",null,"Here is another example where we add a QToggle to each option. The possibilities are endless."),t(i,{title:"Object options",file:"OptionQToggle"}),t("p",null,"By default, when there are no options, the menu won’t appear. But you can customize this scenario and specify what the menu should display."),t(i,{title:"No options slot",file:"OptionNoneSlot"}),t("h3",{id:"lazy-loading",class:"doc-heading doc-h3",onClick:s=>d(c)("lazy-loading")},"Lazy loading",8,["onClick"]),t("p",null,[o("The following example shows a glimpse of how you can play with lazy loading the options. This means, along with many other things, that "),t("code",{class:"doc-token"},"options"),o(" prop is not required on first render.")]),t(i,{title:"Lazy load options",file:"OptionLazyLoad"}),t("p",null,"You can dynamically load new options when scroll reaches the end:"),t(i,{title:"Dynamic loading options",file:"OptionsDynamic"}),t("h3",{id:"cover-mode",class:"doc-heading doc-h3",onClick:s=>d(c)("cover-mode")},"Cover mode",8,["onClick"]),t(i,{title:"Menu covering component",file:"OptionCover"}),t("h2",{id:"the-display-value",class:"doc-heading doc-h2",onClick:s=>d(c)("the-display-value")},"The display value",8,["onClick"]),t(i,{title:"Custom display value",file:"DisplayCustomValue"}),t(i,{title:"Chips as display value",file:"DisplayChips"}),t(i,{title:"Selected-item slot",file:"DisplaySelectedItemSlot"}),t("h2",{id:"filtering-and-autocomplete",class:"doc-heading doc-h2",onClick:s=>d(c)("filtering-and-autocomplete")},"Filtering and autocomplete",8,["onClick"]),t("h3",{id:"native-attributes-with-use-input",class:"doc-heading doc-h3",onClick:s=>d(c)("native-attributes-with-use-input")},"Native attributes with “use-input”",8,["onClick"]),t("p",null,[o("All the attributes set on QSelect that are not in the list of props in the API will be passed to the native input field used (please check "),t("code",{class:"doc-token"},"use-input"),o(" prop description first to understand what it does) for filtering / autocomplete / adding new value. Some examples: autocomplete, placeholder.")]),t("p",null,[o("More information: "),t(h,{to:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input"},{default:u(()=>[o("native input attributes")]),_:1}),o(".")]),t(i,{title:"Filtering options",file:"InputFilterOptions"}),t(i,{title:"Basic filtering",file:"BasicFiltering"}),t(i,{title:"Filtering on more than 2 chars",file:"InputFilterMin"}),t(i,{title:"Text autocomplete",file:"TextAutocomplete"}),t(i,{title:"Lazy filtering",file:"InputFilterLazy"}),t(i,{title:"Selecting option after filtering",file:"InputFilterAfter"}),t("h2",{id:"create-new-values",class:"doc-heading doc-h2",onClick:s=>d(c)("create-new-values")},"Create new values",8,["onClick"]),t("div",{class:"doc-note doc-note--tip"},[t("p",{class:"doc-note__title"},"TIP"),t("p",null,"The following are just a few examples to get you started into making your own QSelect behavior. This is not exhaustive list of possibilities that QSelect offers."),t("p",null,[o("It makes sense to use this feature along with "),t("code",{class:"doc-token"},"use-input"),o(" prop.")])]),t("p",null,[o("In order to enable the creation of new values, you need to "),t("strong",null,"either specify"),o(" the "),t("code",{class:"doc-token"},"new-value-mode"),o(" prop "),t("strong",null,"and/or"),o(" listen for "),t("code",{class:"doc-token"},"@new-value"),o(" event. If you use both, then the purpose of listening to "),t("code",{class:"doc-token"},"@new-value"),o(" would be only to override the "),t("code",{class:"doc-token"},"new-value-mode"),o(" in your custom scenarios.")]),t("h3",{id:"the-new-value-mode-prop",class:"doc-heading doc-h3",onClick:s=>d(c)("the-new-value-mode-prop")},"The new-value-mode prop",8,["onClick"]),t("p",null,[o("The "),t("code",{class:"doc-token"},"new-value-mode"),o(" prop value specifies how the value should be added: "),t("code",{class:"doc-token"},"add"),o(" (adds a value, even if duplicate), "),t("code",{class:"doc-token"},"add-unique"),o(" (add only if NOT duplicate) or "),t("code",{class:"doc-token"},"toggle"),o(" (adds value if it’s not already in model, otherwise it removes it).")]),t("p",null,[o("By using this prop you don’t need to also listen for "),t("code",{class:"doc-token"},"@new-value"),o(" event, unless you have some specific scenarios for which you want to override the behavior.")]),t(i,{title:"New value mode",file:"CreateNewValueMode"}),t("h3",{id:"the-new-value-event",class:"doc-heading doc-h3",onClick:s=>d(c)("the-new-value-event")},"The @new-value event",8,["onClick"]),t("p",null,[o("The "),t("code",{class:"doc-token"},"@new-value"),o(" event is emitted with the value to be added and a "),t("code",{class:"doc-token"},"done"),o(" callback. The "),t("code",{class:"doc-token"},"done"),o(" callback has two "),t("strong",null,"optional"),o(" parameters:")]),t("ul",null,[t("li",null,"the value to be added"),t("li",null,[o("the behavior (same values of "),t("code",{class:"doc-token"},"new-value-mode"),o(" prop, and when it is specified it overrides that prop – if it is used) – default behavior (if not using "),t("code",{class:"doc-token"},"new-value-mode"),o(") is to add the value even if it would be a duplicate")])]),t("p",null,[o("Calling "),t("code",{class:"doc-token"},"done()"),o(" with no parameters simply empties the input box value, without tampering with the model in any way.")]),t(i,{title:"Listening on @new-value",file:"CreateListener"}),t(i,{title:"Adding only unique values",file:"CreateListenerUnique"}),t("h3",{id:"using-menu-and-filtering",class:"doc-heading doc-h3",onClick:s=>d(c)("using-menu-and-filtering")},"Using menu and filtering",8,["onClick"]),t("p",null,"Filtering and adding the new values to menu:"),t(i,{title:"Filtering and adding to menu",file:"FilteringAddsToMenu"}),t("p",null,"Filters new values (in the example below the value to be added requires at least 3 characters to pass), and does not add to menu:"),t(i,{title:"Filtering without adding to menu",file:"FilteringNoAddToMenu"}),t("p",null,"Generating multiple values from input:"),t(i,{title:"Generating multiple values",file:"FilteringAddMultiple"}),t("h2",{id:"sanitization",class:"doc-heading doc-h2",onClick:s=>d(c)("sanitization")},"Sanitization",8,["onClick"]),t("p",null,[t("strong",null,"By default, all options (included selected ones) are sanitized"),o(". This means that displaying them in HTML format is disabled. However, if you require HTML on your options and you trust their content, then there are a few ways to do this.")]),t("p",null,"You can force the HTML form of the menu options by:"),t("ul",null,[t("li",null,[o("setting "),t("code",{class:"doc-token"},"html"),o(" key of the trusted option to "),t("code",{class:"doc-token"},"true"),o(" (for specific trusted options)")]),t("li",null,[o("or by setting "),t("code",{class:"doc-token"},"options-html"),o(" prop of QSelect (for all options)")])]),t("p",null,"The displayed value of QSelect is displayed as HTML if:"),t("ul",null,[t("li",null,[o("the "),t("code",{class:"doc-token"},"display-value-html"),o(" prop of QSelect is set")]),t("li",null,[o("or you are not using "),t("code",{class:"doc-token"},"display-value"),o(" and "),t("ul",null,[t("li",null,[o("the "),t("code",{class:"doc-token"},"options-html"),o(" prop of QSelect is set")]),t("li",null,[o("any selected option has "),t("code",{class:"doc-token"},"html"),o(" key set to "),t("code",{class:"doc-token"},"true")])])])]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[o("If you use "),t("code",{class:"doc-token"},"selected"),o(" or "),t("code",{class:"doc-token"},"selected-item"),o(" slots, then you are responsible for sanitization of the display value. The "),t("code",{class:"doc-token"},"display-value-html"),o(" prop will not apply.")])]),t(i,{title:"Options in HTML form",file:"HtmlOptions"}),t(i,{title:"Display value in HTML form",file:"HtmlDisplayValue"}),t("h2",{id:"render-performance",class:"doc-heading doc-h2",onClick:s=>d(c)("render-performance")},"Render performance",8,["onClick"]),t("p",null,[o("The render performance is NOT affected much by the number of options, unless "),t("code",{class:"doc-token"},"map-options"),o(" is used on a large set. Notice the infinite scroll in place which renders additional options as the user scrolls through the list.")]),t("div",{class:"doc-note doc-note--tip"},[t("p",{class:"doc-note__title"},"TIP"),t("ul",null,[t("li",null,[o("(Composition API) To get the best performance while using lots of options, do not wrap the array that you are passing in the "),t("code",{class:"doc-token"},"options"),o(" prop with ref()/computed()/reactive()/etc. This allows Vue to skip making the list “responsive” to changes.")]),t("li",null,[o("(Options API) To get the best performance while using lots of options, freeze the array that you are passing in the "),t("code",{class:"doc-token"},"options"),o(" prop using "),t("code",{class:"doc-token"},"Object.freeze(items)"),o(". This allows Vue to skip making the list “responsive” to changes.")])])]),t(i,{title:"100k options",file:"RenderPerf"}),t("h2",{id:"keyboard-navigation",class:"doc-heading doc-h2",onClick:s=>d(c)("keyboard-navigation")},"Keyboard navigation",8,["onClick"]),t("p",null,"When QSelect is focused:"),t("ul",null,[t("li",null,[o("pressing "),t("kbd",null,"ENTER"),o(", "),t("kbd",null,"ARROW DOWN"),o(" (or "),t("kbd",null,"SPACE"),o(" if "),t("code",{class:"doc-token"},"use-input"),o(" is not set) will open the list of options")]),t("li",null,[o("if "),t("code",{class:"doc-token"},"use-chips"),o(" is set: "),t("ul",null,[t("li",null,[o("pressing "),t("kbd",null,"SHIFT"),o(" + "),t("kbd",null,"TAB"),o(" will navigate backwards through the QChips (if a QChip is selected "),t("kbd",null,"TAB"),o(" will navigate forward through the QChips)")]),t("li",null,[o("pressing "),t("kbd",null,"ENTER"),o(" when a QChip is selected will remove that option from the selection")]),t("li",null,[o("pressing "),t("kbd",null,"BACKSPACE"),o(" will remove the last option from the selection (when "),t("code",{class:"doc-token"},"use-input"),o(" is set the input should be empty)")])])]),t("li",null,[o("pressing "),t("kbd",null,"BACKSPACE"),o(" when "),t("code",{class:"doc-token"},"clearable"),o(" is set then: "),t("ul",null,[t("li",null,[o("it clears the model (with "),t("code",{class:"doc-token"},"null"),o(" value) for single selection")]),t("li",null,"it removes the last added value for multiple selection")])]),t("li",null,[o("pressing "),t("kbd",null,"TAB"),o(" (or "),t("kbd",null,"SHIFT"),o(" + "),t("kbd",null,"TAB"),o(" if "),t("code",{class:"doc-token"},"use-chips"),o(" is not set or the first QChip is selected) will navigate to the next or previous focusable element on page")]),t("li",null,[o("typing text ("),t("kbd",null,"0"),o(" - "),t("kbd",null,"9"),o(" or "),t("kbd",null,"A"),o(" - "),t("kbd",null,"Z"),o(") if "),t("code",{class:"doc-token"},"use-input"),o(" is not set will: "),t("ul",null,[t("li",null,"create a search buffer (will be reset when a new key is not typed for 1.5 seconds) that will be used to search in the options labels"),t("li",null,"select the next option starting with that letter (after the current focused one) if the first key in buffer is typed multiple times"),t("li",null,"select the next option (starting with the current focused one) that matches the typed text (the match is fuzzy - the option label should start with the first letter and contain all the letters)")])])]),t("p",null,"When the list of options is opened:"),t("ul",null,[t("li",null,[o("pressing "),t("kbd",null,"ARROW UP"),o(" or "),t("kbd",null,"ARROW DOWN"),o(" will navigate up or down in the list of options")]),t("li",null,[o("pressing "),t("kbd",null,"PAGE UP"),o(" or "),t("kbd",null,"PAGE DOWN"),o(" will navigate one page up or down in the list of options")]),t("li",null,[o("pressing "),t("kbd",null,"HOME"),o(" or "),t("kbd",null,"END"),o(" will navigate to the start or end of the list of options (only if you are not using "),t("code",{class:"doc-token"},"use-input"),o(", or the input is empty)")]),t("li",null,"when navigating using arrow keys, navigation will wrap when reaching the start or end of the list"),t("li",null,[o("pressing "),t("kbd",null,"ENTER"),o(" (or "),t("kbd",null,"SPACE"),o(" when "),t("code",{class:"doc-token"},"use-input"),o(" is not set, or "),t("kbd",null,"TAB"),o(" when "),t("code",{class:"doc-token"},"multiple"),o(" is not set) when an option is selected in the list will: "),t("ul",null,[t("li",null,[o("select the option and close the list of options if "),t("code",{class:"doc-token"},"multiple"),o(" is not set")]),t("li",null,[o("toggle the option if "),t("code",{class:"doc-token"},"multiple"),o(" is set")])])])]),t("h2",{id:"native-form-submit",class:"doc-heading doc-h2",onClick:s=>d(c)("native-form-submit")},"Native form submit",8,["onClick"]),t("p",null,[o("When dealing with a native form which has an "),t("code",{class:"doc-token"},"action"),o(" and a "),t("code",{class:"doc-token"},"method"),o(" (eg. when using Quasar with ASP.NET controllers), you need to specify the "),t("code",{class:"doc-token"},"name"),o(" property on QSelect, otherwise formData will not contain it (if it should) - all value are converted to string (native behaviour, so do not use Object values):")]),t(i,{title:"Native form",file:"NativeForm"})]}),_:1},$))}}},w=f.setup;f.setup=(g,p)=>{const m=O();return(m.modules||(m.modules=new Set)).add("src/pages/vue-components/select.md"),w?w(g,p):void 0};const J=N(f,[["__file","select.md"]]);export{J as default};
