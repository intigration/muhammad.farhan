import{resolveComponent as C,mergeProps as q,withCtx as r,unref as c,createVNode as e,createTextVNode as t,useSSRContext as P}from"vue";import{ssrRenderComponent as l}from"vue/server-renderer";import{c as f}from"./page-utils-C-QWsEHe.js";import{D as R,a as k}from"./DocPage-DKr-0pQn.js";import{D as h}from"./DocPrerender-DPOnWPFO.js";import{C as u}from"./CopyButton-l3ndfN49.js";import{_ as A}from"../server-entry.js";import"quasar";import"@quasar/extras/mdi-v6";import"vue-router";import"@quasar/extras/fontawesome-v5";import"@quasar/extras/fontawesome-v6";import"@quasar/extras/mdi-v7";import"quasar/icon-set/svg-mdi-v6.mjs";const w={__name:"writing-universal-code",__ssrInlineRender:!0,setup(g){const m=[{id:"data-reactivity-on-the-server",title:"2. Data Reactivity on the Server"},{id:"component-lifecycle-hooks",title:"3. Component Lifecycle Hooks"},{id:"avoid-stateful-singletons",title:"4. Avoid Stateful Singletons"},{id:"access-to-platform-specific-apis",title:"5. Access to Platform-Specific APIs"},{id:"boot-files",title:"6. Boot Files"},{id:"data-pre-fetching-and-state",title:"7. Data Pre-Fetching and State"}];return(y,$,x,S)=>{const b=C("q-separator");$(l(R,q({title:"Writing Universal Code",desc:"(@quasar/app-vite) Guide on how to write code for a Quasar server-side rendered app.",overline:"Quasar CLI with Vite - @quasar/app-vite",heading:"","edit-link":"quasar-cli-vite/developing-ssr/writing-universal-code",toc:m},S),{default:r((j,o,d,s)=>{if(o)o(`<p${s}>Writing <code class="doc-token"${s}>universal</code> code (also called <code class="doc-token"${s}>isomorphic</code>) means writing code that runs on both the server and the client. Due to use-case and platform API differences, the behavior of our code will not be exactly the same when running in different environments. Here we will go over the key things you need to be aware of.</p><p${s}><img src="https://cdn.quasar.dev/img/ssr-build.png" alt="" title="Quasar SSR Build System" class="doc-img"${s}></p><h2 id="data-reactivity-on-the-server" class="doc-heading doc-h2"${s}>Data Reactivity on the Server</h2><p${s}>In a client-only app, every user will be using a fresh instance of the app in their browser. For server-side rendering we want the same: each request should have a fresh, isolated app instance so that there is no cross-request state pollution.</p><p${s}>Because the actual rendering process needs to be deterministic, we will also be “pre-fetching” data on the server - this means our application state will be already resolved when we start rendering. This means data reactivity is unnecessary on the server, so it is disabled by default. Disabling data reactivity also avoids the performance cost of converting data into reactive objects.</p><h2 id="component-lifecycle-hooks" class="doc-heading doc-h2"${s}>Component Lifecycle Hooks</h2><p${s}>Since there are no dynamic updates, of all the Vue lifecycle hooks, only <code class="doc-token"${s}>beforeCreate</code> and <code class="doc-token"${s}>created</code> will be called during SSR. This means any code inside other lifecycle hooks such as <code class="doc-token"${s}>beforeMount</code> or <code class="doc-token"${s}>mounted</code> will only be executed on the client.</p><p${s}>Another thing to note is that you should avoid code that produces global side effects in <code class="doc-token"${s}>beforeCreate</code> and <code class="doc-token"${s}>created</code>, for example setting up timers with <code class="doc-token"${s}>setInterval</code>. In client-side only code we may setup a timer and then tear it down in <code class="doc-token"${s}>beforeUnmount</code> or <code class="doc-token"${s}>destroyed</code>. However, because the destroy hooks will not be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into <code class="doc-token"${s}>beforeMount</code> or <code class="doc-token"${s}>mounted</code> instead.</p><h2 id="avoid-stateful-singletons" class="doc-heading doc-h2"${s}>Avoid Stateful Singletons</h2><p${s}>When writing client-only code, we are used to the fact that our code will be evaluated in a fresh context every time. However, a Node.js server is a long-running process. When our code is required into the process, it will be evaluated once and then it stays in memory. This means if you create a singleton object, it will be shared between every incoming request.</p><p${s}>So, Quasar CLI creates a new root Vue instance with a new Router and Vuex Store instances for each request. This is similar to how each user will be using a fresh instance of the app in their own browser. If we would have used a shared instance across multiple requests, it will easily lead to cross-request state pollution.</p><p${s}>Instead of directly creating a Router and Vuex Store instances, you’ll be exposing a factory function that can be repeatedly executed to create fresh app instances for each request:</p>`),o(l(c(h),{title:"src/router/index.js"},{default:r((i,a,p,n)=>{if(a)a(`<pre class="doc-code"${n}><code${n}><span class="token keyword"${n}>export</span> <span class="token keyword"${n}>default</span> <span class="token keyword"${n}>function</span> <span class="token punctuation"${n}>(</span><span class="token comment"${n}>/* { store, ssrContext } */</span><span class="token punctuation"${n}>)</span> <span class="token punctuation"${n}>{</span>
  <span class="token keyword"${n}>const</span> Router <span class="token operator"${n}>=</span> <span class="token keyword"${n}>new</span> <span class="token class-name"${n}>VueRouter</span><span class="token punctuation"${n}>(</span><span class="token punctuation"${n}>{</span><span class="token operator"${n}>...</span><span class="token punctuation"${n}>}</span><span class="token punctuation"${n}>)</span>
  <span class="token keyword"${n}>return</span> Router
<span class="token punctuation"${n}>}</span></code></pre>`),a(l(u,null,null,p,n));else return[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"export"),t(),e("span",{class:"token keyword"},"default"),t(),e("span",{class:"token keyword"},"function"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token comment"},"/* { store, ssrContext } */"),e("span",{class:"token punctuation"},")"),t(),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token keyword"},"const"),t(" Router "),e("span",{class:"token operator"},"="),t(),e("span",{class:"token keyword"},"new"),t(),e("span",{class:"token class-name"},"VueRouter"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token operator"},"..."),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},")"),t(`
  `),e("span",{class:"token keyword"},"return"),t(` Router
`),e("span",{class:"token punctuation"},"}")])]),e(u)]}),_:1},d,s)),o(l(c(h),{title:"src/store/index.js"},{default:r((i,a,p,n)=>{if(a)a(`<pre class="doc-code"${n}><code${n}><span class="token keyword"${n}>export</span> <span class="token keyword"${n}>default</span> <span class="token keyword"${n}>function</span> <span class="token punctuation"${n}>(</span><span class="token comment"${n}>/* { ssrContext } */</span><span class="token punctuation"${n}>)</span> <span class="token punctuation"${n}>{</span>
  <span class="token keyword"${n}>const</span> Store <span class="token operator"${n}>=</span> <span class="token keyword"${n}>new</span> <span class="token class-name"${n}>Vuex<span class="token punctuation"${n}>.</span>Store</span><span class="token punctuation"${n}>(</span><span class="token punctuation"${n}>{</span><span class="token operator"${n}>...</span><span class="token punctuation"${n}>}</span><span class="token punctuation"${n}>)</span>
  <span class="token keyword"${n}>return</span> Store
<span class="token punctuation"${n}>}</span></code></pre>`),a(l(u,null,null,p,n));else return[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"export"),t(),e("span",{class:"token keyword"},"default"),t(),e("span",{class:"token keyword"},"function"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token comment"},"/* { ssrContext } */"),e("span",{class:"token punctuation"},")"),t(),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token keyword"},"const"),t(" Store "),e("span",{class:"token operator"},"="),t(),e("span",{class:"token keyword"},"new"),t(),e("span",{class:"token class-name"},[t("Vuex"),e("span",{class:"token punctuation"},"."),t("Store")]),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token operator"},"..."),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},")"),t(`
  `),e("span",{class:"token keyword"},"return"),t(` Store
`),e("span",{class:"token punctuation"},"}")])]),e(u)]}),_:1},d,s)),o(`<p${s}>If you’re using `),o(l(k,{to:"https://vuex.vuejs.org/guide/modules.html"},{default:r((i,a,p,n)=>{if(a)a("Vuex modules");else return[t("Vuex modules")]}),_:1},d,s)),o(" don’t forget to export the state as a function otherwise a singleton will be created:</p>"),o(l(c(h),{title:"src/store/myModule/state.js"},{default:r((i,a,p,n)=>{if(a)a(`<pre class="doc-code"${n}><code${n}><span class="token keyword"${n}>export</span> <span class="token keyword"${n}>default</span> <span class="token punctuation"${n}>(</span><span class="token punctuation"${n}>)</span> <span class="token operator"${n}>=&gt;</span> <span class="token punctuation"${n}>(</span><span class="token punctuation"${n}>{</span>
  <span class="token operator"${n}>...</span>
<span class="token punctuation"${n}>}</span><span class="token punctuation"${n}>)</span></code></pre>`),a(l(u,null,null,p,n));else return[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"export"),t(),e("span",{class:"token keyword"},"default"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),t(),e("span",{class:"token operator"},"=>"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token operator"},"..."),t(`
`),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},")")])]),e(u)]}),_:1},d,s)),o(`<h2 id="access-to-platform-specific-apis" class="doc-heading doc-h2"${s}>Access to Platform-Specific APIs</h2><p${s}>Universal code cannot assume access to platform-specific APIs, so if your code directly uses browser-only globals like <code class="doc-token"${s}>window</code> or <code class="doc-token"${s}>document</code>, they will throw errors when executed in Node.js, and vice-versa.</p><p${s}>For tasks shared between server and client but use different platform APIs, it’s recommended to wrap the platform-specific implementations inside a universal API, or use libraries that do this for you. For example, `),o(l(k,{to:"https://github.com/axios/axios"},{default:r((i,a,p,n)=>{if(a)a("Axios");else return[t("Axios")]}),_:1},d,s)),o(` is an HTTP client that exposes the same API for both server and client.</p><p${s}>For browser-only APIs, the common approach is to lazily access them inside client-only lifecycle hooks.</p><h2 id="boot-files" class="doc-heading doc-h2"${s}>Boot Files</h2><p${s}>Note that if a 3rd party library is not written with universal usage in mind, it could be tricky to integrate it into a server-rendered app. You <em${s}>might</em> be able to get it working by mocking some of the globals, but it would be hacky and may interfere with the environment detection code of other libraries.</p><p${s}>When you add a 3rd party library to your project (through a `),o(l(k,{to:"/quasar-cli-vite/boot-files"},{default:r((i,a,p,n)=>{if(a)a("Boot File");else return[t("Boot File")]}),_:1},d,s)),o(`), take into consideration whether it can run on server and on client. If it needs to run only on server or only on client, then specify this in the <code class="doc-token"${s}>/quasar.config</code> file:</p>`),o(l(c(h),{title:"/quasar.config file"},{default:r((i,a,p,n)=>{if(a)a(`<pre class="doc-code"${n}><code${n}><span class="token keyword"${n}>return</span> <span class="token punctuation"${n}>{</span>
  <span class="token comment"${n}>// ...</span>
  <span class="token literal-property property"${n}>boot</span><span class="token operator"${n}>:</span> <span class="token punctuation"${n}>[</span>
    <span class="token string"${n}>&#39;some-boot-file&#39;</span><span class="token punctuation"${n}>,</span> <span class="token comment"${n}>// runs on both server &amp; client</span>
    <span class="token punctuation"${n}>{</span> <span class="token literal-property property"${n}>path</span><span class="token operator"${n}>:</span> <span class="token string"${n}>&#39;some-other&#39;</span><span class="token punctuation"${n}>,</span> <span class="token literal-property property"${n}>server</span><span class="token operator"${n}>:</span> <span class="token boolean"${n}>false</span> <span class="token punctuation"${n}>}</span> <span class="token comment"${n}>// this boot file gets embedded only on client-side</span>
    <span class="token punctuation"${n}>{</span> <span class="token literal-property property"${n}>path</span><span class="token operator"${n}>:</span> <span class="token string"${n}>&#39;third&#39;</span><span class="token punctuation"${n}>,</span> <span class="token literal-property property"${n}>client</span><span class="token operator"${n}>:</span> <span class="token boolean"${n}>false</span> <span class="token punctuation"${n}>}</span> <span class="token comment"${n}>// this boot file gets embedded only on server-side</span>
  <span class="token punctuation"${n}>]</span>
<span class="token punctuation"${n}>}</span></code></pre>`),a(l(u,null,null,p,n));else return[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"return"),t(),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token comment"},"// ..."),t(`
  `),e("span",{class:"token literal-property property"},"boot"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token punctuation"},"["),t(`
    `),e("span",{class:"token string"},"'some-boot-file'"),e("span",{class:"token punctuation"},","),t(),e("span",{class:"token comment"},"// runs on both server & client"),t(`
    `),e("span",{class:"token punctuation"},"{"),t(),e("span",{class:"token literal-property property"},"path"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token string"},"'some-other'"),e("span",{class:"token punctuation"},","),t(),e("span",{class:"token literal-property property"},"server"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token boolean"},"false"),t(),e("span",{class:"token punctuation"},"}"),t(),e("span",{class:"token comment"},"// this boot file gets embedded only on client-side"),t(`
    `),e("span",{class:"token punctuation"},"{"),t(),e("span",{class:"token literal-property property"},"path"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token string"},"'third'"),e("span",{class:"token punctuation"},","),t(),e("span",{class:"token literal-property property"},"client"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token boolean"},"false"),t(),e("span",{class:"token punctuation"},"}"),t(),e("span",{class:"token comment"},"// this boot file gets embedded only on server-side"),t(`
  `),e("span",{class:"token punctuation"},"]"),t(`
`),e("span",{class:"token punctuation"},"}")])]),e(u)]}),_:1},d,s)),o(`<h2 id="data-pre-fetching-and-state" class="doc-heading doc-h2"${s}>Data Pre-Fetching and State</h2><p${s}>During SSR, we are essentially rendering a “snapshot” of our app, so if the app relies on some asynchronous data, this data need to be pre-fetched and resolved before we start the rendering process.</p><p${s}>The Quasar CLI `),o(l(k,{to:"/quasar-cli-vite/prefetch-feature"},{default:r((i,a,p,n)=>{if(a)a("PreFetch Feature");else return[t("PreFetch Feature")]}),_:1},d,s)),o(" has been created to solve this problem. Take a few moments to read about it.</p>"),o(l(b,{class:"q-mt-xl"},null,d,s)),o(`<blockquote class="doc-note"${s}><p${s}>Parts of this page are taken from the official `),o(l(k,{to:"https://vuejs.org/guide/scaling-up/ssr.html#component-lifecycle-hooks"},{default:r((i,a,p,n)=>{if(a)a("Vue.js SSR guide");else return[t("Vue.js SSR guide")]}),_:1},d,s)),o(".</p></blockquote>");else return[e("p",null,[t("Writing "),e("code",{class:"doc-token"},"universal"),t(" code (also called "),e("code",{class:"doc-token"},"isomorphic"),t(") means writing code that runs on both the server and the client. Due to use-case and platform API differences, the behavior of our code will not be exactly the same when running in different environments. Here we will go over the key things you need to be aware of.")]),e("p",null,[e("img",{src:"https://cdn.quasar.dev/img/ssr-build.png",alt:"",title:"Quasar SSR Build System",class:"doc-img"})]),e("h2",{id:"data-reactivity-on-the-server",class:"doc-heading doc-h2",onClick:i=>c(f)("data-reactivity-on-the-server")},"Data Reactivity on the Server",8,["onClick"]),e("p",null,"In a client-only app, every user will be using a fresh instance of the app in their browser. For server-side rendering we want the same: each request should have a fresh, isolated app instance so that there is no cross-request state pollution."),e("p",null,"Because the actual rendering process needs to be deterministic, we will also be “pre-fetching” data on the server - this means our application state will be already resolved when we start rendering. This means data reactivity is unnecessary on the server, so it is disabled by default. Disabling data reactivity also avoids the performance cost of converting data into reactive objects."),e("h2",{id:"component-lifecycle-hooks",class:"doc-heading doc-h2",onClick:i=>c(f)("component-lifecycle-hooks")},"Component Lifecycle Hooks",8,["onClick"]),e("p",null,[t("Since there are no dynamic updates, of all the Vue lifecycle hooks, only "),e("code",{class:"doc-token"},"beforeCreate"),t(" and "),e("code",{class:"doc-token"},"created"),t(" will be called during SSR. This means any code inside other lifecycle hooks such as "),e("code",{class:"doc-token"},"beforeMount"),t(" or "),e("code",{class:"doc-token"},"mounted"),t(" will only be executed on the client.")]),e("p",null,[t("Another thing to note is that you should avoid code that produces global side effects in "),e("code",{class:"doc-token"},"beforeCreate"),t(" and "),e("code",{class:"doc-token"},"created"),t(", for example setting up timers with "),e("code",{class:"doc-token"},"setInterval"),t(". In client-side only code we may setup a timer and then tear it down in "),e("code",{class:"doc-token"},"beforeUnmount"),t(" or "),e("code",{class:"doc-token"},"destroyed"),t(". However, because the destroy hooks will not be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into "),e("code",{class:"doc-token"},"beforeMount"),t(" or "),e("code",{class:"doc-token"},"mounted"),t(" instead.")]),e("h2",{id:"avoid-stateful-singletons",class:"doc-heading doc-h2",onClick:i=>c(f)("avoid-stateful-singletons")},"Avoid Stateful Singletons",8,["onClick"]),e("p",null,"When writing client-only code, we are used to the fact that our code will be evaluated in a fresh context every time. However, a Node.js server is a long-running process. When our code is required into the process, it will be evaluated once and then it stays in memory. This means if you create a singleton object, it will be shared between every incoming request."),e("p",null,"So, Quasar CLI creates a new root Vue instance with a new Router and Vuex Store instances for each request. This is similar to how each user will be using a fresh instance of the app in their own browser. If we would have used a shared instance across multiple requests, it will easily lead to cross-request state pollution."),e("p",null,"Instead of directly creating a Router and Vuex Store instances, you’ll be exposing a factory function that can be repeatedly executed to create fresh app instances for each request:"),e(c(h),{title:"src/router/index.js"},{default:r(()=>[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"export"),t(),e("span",{class:"token keyword"},"default"),t(),e("span",{class:"token keyword"},"function"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token comment"},"/* { store, ssrContext } */"),e("span",{class:"token punctuation"},")"),t(),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token keyword"},"const"),t(" Router "),e("span",{class:"token operator"},"="),t(),e("span",{class:"token keyword"},"new"),t(),e("span",{class:"token class-name"},"VueRouter"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token operator"},"..."),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},")"),t(`
  `),e("span",{class:"token keyword"},"return"),t(` Router
`),e("span",{class:"token punctuation"},"}")])]),e(u)]),_:1}),e(c(h),{title:"src/store/index.js"},{default:r(()=>[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"export"),t(),e("span",{class:"token keyword"},"default"),t(),e("span",{class:"token keyword"},"function"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token comment"},"/* { ssrContext } */"),e("span",{class:"token punctuation"},")"),t(),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token keyword"},"const"),t(" Store "),e("span",{class:"token operator"},"="),t(),e("span",{class:"token keyword"},"new"),t(),e("span",{class:"token class-name"},[t("Vuex"),e("span",{class:"token punctuation"},"."),t("Store")]),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token operator"},"..."),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},")"),t(`
  `),e("span",{class:"token keyword"},"return"),t(` Store
`),e("span",{class:"token punctuation"},"}")])]),e(u)]),_:1}),e("p",null,[t("If you’re using "),e(k,{to:"https://vuex.vuejs.org/guide/modules.html"},{default:r(()=>[t("Vuex modules")]),_:1}),t(" don’t forget to export the state as a function otherwise a singleton will be created:")]),e(c(h),{title:"src/store/myModule/state.js"},{default:r(()=>[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"export"),t(),e("span",{class:"token keyword"},"default"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),t(),e("span",{class:"token operator"},"=>"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token operator"},"..."),t(`
`),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},")")])]),e(u)]),_:1}),e("h2",{id:"access-to-platform-specific-apis",class:"doc-heading doc-h2",onClick:i=>c(f)("access-to-platform-specific-apis")},"Access to Platform-Specific APIs",8,["onClick"]),e("p",null,[t("Universal code cannot assume access to platform-specific APIs, so if your code directly uses browser-only globals like "),e("code",{class:"doc-token"},"window"),t(" or "),e("code",{class:"doc-token"},"document"),t(", they will throw errors when executed in Node.js, and vice-versa.")]),e("p",null,[t("For tasks shared between server and client but use different platform APIs, it’s recommended to wrap the platform-specific implementations inside a universal API, or use libraries that do this for you. For example, "),e(k,{to:"https://github.com/axios/axios"},{default:r(()=>[t("Axios")]),_:1}),t(" is an HTTP client that exposes the same API for both server and client.")]),e("p",null,"For browser-only APIs, the common approach is to lazily access them inside client-only lifecycle hooks."),e("h2",{id:"boot-files",class:"doc-heading doc-h2",onClick:i=>c(f)("boot-files")},"Boot Files",8,["onClick"]),e("p",null,[t("Note that if a 3rd party library is not written with universal usage in mind, it could be tricky to integrate it into a server-rendered app. You "),e("em",null,"might"),t(" be able to get it working by mocking some of the globals, but it would be hacky and may interfere with the environment detection code of other libraries.")]),e("p",null,[t("When you add a 3rd party library to your project (through a "),e(k,{to:"/quasar-cli-vite/boot-files"},{default:r(()=>[t("Boot File")]),_:1}),t("), take into consideration whether it can run on server and on client. If it needs to run only on server or only on client, then specify this in the "),e("code",{class:"doc-token"},"/quasar.config"),t(" file:")]),e(c(h),{title:"/quasar.config file"},{default:r(()=>[e("pre",{class:"doc-code"},[e("code",null,[e("span",{class:"token keyword"},"return"),t(),e("span",{class:"token punctuation"},"{"),t(`
  `),e("span",{class:"token comment"},"// ..."),t(`
  `),e("span",{class:"token literal-property property"},"boot"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token punctuation"},"["),t(`
    `),e("span",{class:"token string"},"'some-boot-file'"),e("span",{class:"token punctuation"},","),t(),e("span",{class:"token comment"},"// runs on both server & client"),t(`
    `),e("span",{class:"token punctuation"},"{"),t(),e("span",{class:"token literal-property property"},"path"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token string"},"'some-other'"),e("span",{class:"token punctuation"},","),t(),e("span",{class:"token literal-property property"},"server"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token boolean"},"false"),t(),e("span",{class:"token punctuation"},"}"),t(),e("span",{class:"token comment"},"// this boot file gets embedded only on client-side"),t(`
    `),e("span",{class:"token punctuation"},"{"),t(),e("span",{class:"token literal-property property"},"path"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token string"},"'third'"),e("span",{class:"token punctuation"},","),t(),e("span",{class:"token literal-property property"},"client"),e("span",{class:"token operator"},":"),t(),e("span",{class:"token boolean"},"false"),t(),e("span",{class:"token punctuation"},"}"),t(),e("span",{class:"token comment"},"// this boot file gets embedded only on server-side"),t(`
  `),e("span",{class:"token punctuation"},"]"),t(`
`),e("span",{class:"token punctuation"},"}")])]),e(u)]),_:1}),e("h2",{id:"data-pre-fetching-and-state",class:"doc-heading doc-h2",onClick:i=>c(f)("data-pre-fetching-and-state")},"Data Pre-Fetching and State",8,["onClick"]),e("p",null,"During SSR, we are essentially rendering a “snapshot” of our app, so if the app relies on some asynchronous data, this data need to be pre-fetched and resolved before we start the rendering process."),e("p",null,[t("The Quasar CLI "),e(k,{to:"/quasar-cli-vite/prefetch-feature"},{default:r(()=>[t("PreFetch Feature")]),_:1}),t(" has been created to solve this problem. Take a few moments to read about it.")]),e(b,{class:"q-mt-xl"}),e("blockquote",{class:"doc-note"},[e("p",null,[t("Parts of this page are taken from the official "),e(k,{to:"https://vuejs.org/guide/scaling-up/ssr.html#component-lifecycle-hooks"},{default:r(()=>[t("Vue.js SSR guide")]),_:1}),t(".")])])]}),_:1},x))}}},v=w.setup;w.setup=(g,m)=>{const y=P();return(y.modules||(y.modules=new Set)).add("src/pages/quasar-cli-vite/developing-ssr/writing-universal-code.md"),v?v(g,m):void 0};const G=A(w,[["__file","writing-universal-code.md"]]);export{G as default};
