import{provide as w,mergeProps as k,withCtx as v,createVNode as t,unref as n,createTextVNode as i,useSSRContext as $}from"vue";import{ssrRenderComponent as a}from"vue/server-renderer";import{c as r}from"./page-utils-C-QWsEHe.js";import{D as S}from"./DocPage-DKr-0pQn.js";import{D as l}from"./DocExample-BcaABDtE.js";import{D as f}from"./DocApi-Df9ryd6x.js";import{_ as z}from"../server-entry.js";import"quasar";import"@quasar/extras/mdi-v6";import"@quasar/extras/fontawesome-v6";import"@quasar/extras/mdi-v7";import"./DocCode-BVg0tuSc.js";import"prismjs";import"./CopyButton-l3ndfN49.js";import"./DocCodepen-BPVszLIH.js";import"./utils-DKnLoYai.js";import"./DocCardTitle-BSnqQsiz.js";import"vue-router";import"@quasar/extras/fontawesome-v5";import"quasar/icon-set/svg-mdi-v6.mjs";const u={__name:"virtual-scroll",__ssrInlineRender:!0,setup(m){w("_q_ex",{name:"QVirtualScroll"});const h=[{name:"Intersection",category:"Vue Components",path:"/vue-components/intersection"},{name:"Infinite Scroll",category:"Vue Components",path:"/vue-components/infinite-scroll"}],d=[{id:"qvirtualscroll-api",title:"2. QVirtualScroll API",deep:!0},{id:"usage",title:"3. Usage"},{id:"basic",title:"3.1. Basic",sub:!0},{id:"horizontal",title:"3.2. Horizontal",sub:!0},{id:"different-templates",title:"3.3. Different templates",sub:!0},{id:"table-type",title:"3.4. Table type",sub:!0},{id:"scroll-target",title:"3.5. Scroll target",sub:!0},{id:"scroll-to-position",title:"3.6. Scroll to position",sub:!0},{id:"sync-and-async",title:"3.7. Sync and async",sub:!0},{id:"utility-classes",title:"3.8. Utility classes",sub:!0}];return(T,g,y,b)=>{g(a(S,k({title:"Virtual Scroll",desc:"The QVirtualScroll component renders a big list of items as the user scrolls in the container, keeping DOM tree clean and eating the lowest amount of memory possible.",heading:"","edit-link":"vue-components/virtual-scroll",toc:d,related:h},b),{default:v((V,o,s,e)=>{if(o)o(`<p${e}>The QVirtualScroll component allows you to display only a part of a long list of items and update the visible items as the user scrolls in the container. This has several advantages: only visible items are rendered, so the smallest number of nodes are in the DOM tree at any given point in time and the memory consumption is kept at its lowest.</p><p${e}>There are currently two types of QVirtualScroll: “list” (using QItems) and “table” (using a tabular style to display rows of data).</p>`),o(a(f,{file:"QVirtualScroll"},null,s,e)),o(`<h2 id="usage" class="doc-heading doc-h2"${e}>Usage</h2><div class="doc-note doc-note--tip"${e}><p class="doc-note__title"${e}>TIP</p><ul${e}><li${e}>(Composition API) To get the best performance while using large lists, do not wrap the array that you are passing in the <code class="doc-token"${e}>items</code> prop with ref()/computed()/reactive()/etc. This allows Vue to skip making the list “responsive” to changes.</li><li${e}>(Options API) To get the best performance while using large lists, freeze the array that you are passing in the <code class="doc-token"${e}>items</code> prop using <code class="doc-token"${e}>Object.freeze(items)</code>. This allows Vue to skip making the list “responsive” to changes.</li><li${e}>The number of items that will be rendered will be calculated based on the <code class="doc-token"${e}>virtual-scroll-item-size</code> prop and the size of the scrollable area, but you can fit it to your needs using the <code class="doc-token"${e}>virtual-scroll-slice-size</code> prop.</li><li${e}>Use the <code class="doc-token"${e}>virtual-scroll-item-size</code> to specify the size of elements (pixels of height, or width if horizontal). After an element is rendered on screen its size is updated automatically, but if you specify an element size close to the real size you’ll get a better initial indication of the scroll position. Regardless if you will be using this property or not, QVirtualScroll will still work, but without it you may experience the scrollbar not following the mouse grab position while continuously scrolling (on desktop) or the actual scroll of the container getting slightly off by one or two elements when on mobile and continuously scrolling.</li></ul></div><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>There is a maximum height of the scrolling container, imposed by each browser. In IE11 this is around 1,000,000px, while in the rest of the browsers it’s much more, but still limited.</p></div><p${e}>Scroll the examples below to see QVirtualScroll in action.</p><h3 id="basic" class="doc-heading doc-h3"${e}>Basic</h3>`),o(a(l,{title:"Basic",file:"Basic"},null,s,e)),o(`<h3 id="horizontal" class="doc-heading doc-h3"${e}>Horizontal</h3>`),o(a(l,{title:"Horizontal",file:"BasicHorizontal"},null,s,e)),o(`<h3 id="different-templates" class="doc-heading doc-h3"${e}>Different templates</h3>`),o(a(l,{title:"Different templates for items",file:"VariousContent"},null,s,e)),o(a(l,{title:"Different templates for horizontal items",file:"VariousContentHorizontal"},null,s,e)),o(`<h3 id="table-type" class="doc-heading doc-h3"${e}>Table type</h3><p${e}>Notice the <code class="doc-token"${e}>type=&quot;table&quot;</code> property.</p>`),o(a(l,{title:"Basic table",file:"TableBasic"},null,s,e)),o(`<p${e}>With header that scrolls along with content (doesn’t stay in place).</p>`),o(a(l,{title:"Table with scrolling header/footer",file:"TableBasicHeader"},null,s,e)),o(`<p${e}>Notice (in the example below) the CSS required to make the table header and footer “sticky”. Also note the additional scoped slots which define the header and footer content.</p>`),o(a(l,{title:"Sticky headers table",file:"TableSticky"},null,s,e)),o(`<p${e}>A more involved example below, playing with sticky headers and footers.</p>`),o(a(l,{title:"Playing with sticky headers",file:"TableSticky2"},null,s,e)),o(`<h3 id="scroll-target" class="doc-heading doc-h3"${e}>Scroll target</h3><p${e}>If you need to specify the scroll target (because the auto detected one is not the desired one) pass a CSS selector (as string) or the DOM element to the <code class="doc-token"${e}>scroll-target</code> prop.</p><p${e}>If you need to use the virtual list with the whole page as the scrolling element then please set <code class="doc-token"${e}>scroll-target=&quot;body&quot;</code>.</p><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><ul${e}><li${e}>If you pass a custom scroll target container with <code class="doc-token"${e}>scroll-target</code> prop you must make sure that the element exists and that it can be overflowed (it must have a maximum height and an overflow that allows scrolling).</li><li${e}>If the scroll target container cannot be overflowed you’ll get the whole list rendered.</li></ul></div><div class="doc-note doc-note--danger"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>If you want to use a Vue reference for <code class="doc-token"${e}>scroll-target</code>, please take care to set it after mounting the component, like in the example below.</p></div>`),o(a(l,{title:"Custom scroll target by id",file:"ScrollTargetId"},null,s,e)),o(a(l,{title:"Custom scroll target by ref",file:"ScrollTargetRef"},null,s,e)),o(a(l,{title:"Using QScrollArea",file:"ScrollArea"},null,s,e)),o(`<h3 id="scroll-to-position" class="doc-heading doc-h3"${e}>Scroll to position</h3>`),o(a(l,{title:"Scroll to position",file:"ScrollTo"},null,s,e)),o(`<h3 id="sync-and-async" class="doc-heading doc-h3"${e}>Sync and async</h3><p${e}>You can also generate the items to be displayed on the list by using the <code class="doc-token"${e}>items-fn</code> prop.</p><div class="doc-note doc-note--warning"${e}><p class="doc-note__title"${e}>WARNING</p><p${e}>Make sure to use a synchronous function that returns the list of items to be displayed.</p></div><p${e}>If you need async data use a component that retrieves and renders the data.</p>`),o(a(l,{title:"Generate items on the fly",file:"GenerateItems"},null,s,e)),o(`<h3 id="utility-classes" class="doc-heading doc-h3"${e}>Utility classes</h3><p${e}>There are two CSS classes that you can use (should you need to) to control VirtualScroll size calculation:</p><ul${e}><li${e}>Use <code class="doc-token"${e}>q-virtual-scroll--with-prev</code> class on an element rendered by the VirtualScroll to indicate the element should be grouped with the previous one (main use case is for multiple table rows generated from the same row of data).</li><li${e}>Use <code class="doc-token"${e}>q-virtual-scroll--skip</code> class on an element rendered by the VirtualScroll to indicate the element size should be ignored in size calculations.</li></ul>`),o(a(l,{title:"Virtual scroll with multiple rows for a data row",file:"VirtscrollMultipleRows"},null,s,e)),o(a(l,{title:"Virtual scroll with expansion model",file:"VirtscrollExpandedRow"},null,s,e));else return[t("p",null,"The QVirtualScroll component allows you to display only a part of a long list of items and update the visible items as the user scrolls in the container. This has several advantages: only visible items are rendered, so the smallest number of nodes are in the DOM tree at any given point in time and the memory consumption is kept at its lowest."),t("p",null,"There are currently two types of QVirtualScroll: “list” (using QItems) and “table” (using a tabular style to display rows of data)."),t(f,{file:"QVirtualScroll"}),t("h2",{id:"usage",class:"doc-heading doc-h2",onClick:c=>n(r)("usage")},"Usage",8,["onClick"]),t("div",{class:"doc-note doc-note--tip"},[t("p",{class:"doc-note__title"},"TIP"),t("ul",null,[t("li",null,[i("(Composition API) To get the best performance while using large lists, do not wrap the array that you are passing in the "),t("code",{class:"doc-token"},"items"),i(" prop with ref()/computed()/reactive()/etc. This allows Vue to skip making the list “responsive” to changes.")]),t("li",null,[i("(Options API) To get the best performance while using large lists, freeze the array that you are passing in the "),t("code",{class:"doc-token"},"items"),i(" prop using "),t("code",{class:"doc-token"},"Object.freeze(items)"),i(". This allows Vue to skip making the list “responsive” to changes.")]),t("li",null,[i("The number of items that will be rendered will be calculated based on the "),t("code",{class:"doc-token"},"virtual-scroll-item-size"),i(" prop and the size of the scrollable area, but you can fit it to your needs using the "),t("code",{class:"doc-token"},"virtual-scroll-slice-size"),i(" prop.")]),t("li",null,[i("Use the "),t("code",{class:"doc-token"},"virtual-scroll-item-size"),i(" to specify the size of elements (pixels of height, or width if horizontal). After an element is rendered on screen its size is updated automatically, but if you specify an element size close to the real size you’ll get a better initial indication of the scroll position. Regardless if you will be using this property or not, QVirtualScroll will still work, but without it you may experience the scrollbar not following the mouse grab position while continuously scrolling (on desktop) or the actual scroll of the container getting slightly off by one or two elements when on mobile and continuously scrolling.")])])]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,"There is a maximum height of the scrolling container, imposed by each browser. In IE11 this is around 1,000,000px, while in the rest of the browsers it’s much more, but still limited.")]),t("p",null,"Scroll the examples below to see QVirtualScroll in action."),t("h3",{id:"basic",class:"doc-heading doc-h3",onClick:c=>n(r)("basic")},"Basic",8,["onClick"]),t(l,{title:"Basic",file:"Basic"}),t("h3",{id:"horizontal",class:"doc-heading doc-h3",onClick:c=>n(r)("horizontal")},"Horizontal",8,["onClick"]),t(l,{title:"Horizontal",file:"BasicHorizontal"}),t("h3",{id:"different-templates",class:"doc-heading doc-h3",onClick:c=>n(r)("different-templates")},"Different templates",8,["onClick"]),t(l,{title:"Different templates for items",file:"VariousContent"}),t(l,{title:"Different templates for horizontal items",file:"VariousContentHorizontal"}),t("h3",{id:"table-type",class:"doc-heading doc-h3",onClick:c=>n(r)("table-type")},"Table type",8,["onClick"]),t("p",null,[i("Notice the "),t("code",{class:"doc-token"},'type="table"'),i(" property.")]),t(l,{title:"Basic table",file:"TableBasic"}),t("p",null,"With header that scrolls along with content (doesn’t stay in place)."),t(l,{title:"Table with scrolling header/footer",file:"TableBasicHeader"}),t("p",null,"Notice (in the example below) the CSS required to make the table header and footer “sticky”. Also note the additional scoped slots which define the header and footer content."),t(l,{title:"Sticky headers table",file:"TableSticky"}),t("p",null,"A more involved example below, playing with sticky headers and footers."),t(l,{title:"Playing with sticky headers",file:"TableSticky2"}),t("h3",{id:"scroll-target",class:"doc-heading doc-h3",onClick:c=>n(r)("scroll-target")},"Scroll target",8,["onClick"]),t("p",null,[i("If you need to specify the scroll target (because the auto detected one is not the desired one) pass a CSS selector (as string) or the DOM element to the "),t("code",{class:"doc-token"},"scroll-target"),i(" prop.")]),t("p",null,[i("If you need to use the virtual list with the whole page as the scrolling element then please set "),t("code",{class:"doc-token"},'scroll-target="body"'),i(".")]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("ul",null,[t("li",null,[i("If you pass a custom scroll target container with "),t("code",{class:"doc-token"},"scroll-target"),i(" prop you must make sure that the element exists and that it can be overflowed (it must have a maximum height and an overflow that allows scrolling).")]),t("li",null,"If the scroll target container cannot be overflowed you’ll get the whole list rendered.")])]),t("div",{class:"doc-note doc-note--danger"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,[i("If you want to use a Vue reference for "),t("code",{class:"doc-token"},"scroll-target"),i(", please take care to set it after mounting the component, like in the example below.")])]),t(l,{title:"Custom scroll target by id",file:"ScrollTargetId"}),t(l,{title:"Custom scroll target by ref",file:"ScrollTargetRef"}),t(l,{title:"Using QScrollArea",file:"ScrollArea"}),t("h3",{id:"scroll-to-position",class:"doc-heading doc-h3",onClick:c=>n(r)("scroll-to-position")},"Scroll to position",8,["onClick"]),t(l,{title:"Scroll to position",file:"ScrollTo"}),t("h3",{id:"sync-and-async",class:"doc-heading doc-h3",onClick:c=>n(r)("sync-and-async")},"Sync and async",8,["onClick"]),t("p",null,[i("You can also generate the items to be displayed on the list by using the "),t("code",{class:"doc-token"},"items-fn"),i(" prop.")]),t("div",{class:"doc-note doc-note--warning"},[t("p",{class:"doc-note__title"},"WARNING"),t("p",null,"Make sure to use a synchronous function that returns the list of items to be displayed.")]),t("p",null,"If you need async data use a component that retrieves and renders the data."),t(l,{title:"Generate items on the fly",file:"GenerateItems"}),t("h3",{id:"utility-classes",class:"doc-heading doc-h3",onClick:c=>n(r)("utility-classes")},"Utility classes",8,["onClick"]),t("p",null,"There are two CSS classes that you can use (should you need to) to control VirtualScroll size calculation:"),t("ul",null,[t("li",null,[i("Use "),t("code",{class:"doc-token"},"q-virtual-scroll--with-prev"),i(" class on an element rendered by the VirtualScroll to indicate the element should be grouped with the previous one (main use case is for multiple table rows generated from the same row of data).")]),t("li",null,[i("Use "),t("code",{class:"doc-token"},"q-virtual-scroll--skip"),i(" class on an element rendered by the VirtualScroll to indicate the element size should be ignored in size calculations.")])]),t(l,{title:"Virtual scroll with multiple rows for a data row",file:"VirtscrollMultipleRows"}),t(l,{title:"Virtual scroll with expansion model",file:"VirtscrollExpandedRow"})]}),_:1},y))}}},p=u.setup;u.setup=(m,h)=>{const d=$();return(d.modules||(d.modules=new Set)).add("src/pages/vue-components/virtual-scroll.md"),p?p(m,h):void 0};const J=z(u,[["__file","virtual-scroll.md"]]);export{J as default};
